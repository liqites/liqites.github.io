---
layout: post
title: Elasticsearch - The Definitive Guide - Chapter 4
author: Tesla Lee
date: 2018-05-08 19:03:50 +0800
categories: [elasticsearch]
---
分布式文档存储

<!--more-->

## 路由一个文档到一个分片中
当索引一个文档的时候，文档会被存储到一个主分片中。

如何决定存储在哪个分片中？

`shard = hash(routing) % number_of_primary_shards`

`routing` 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 `routing` 通过 `hash` 函数生成一个数字，然后这个数字再除以 `number_of_primary_shards` （主分片的数量）后得到 余数 。

所有的文档 API（ `get` 、 `index` 、 `delete` 、 `bulk` 、 `update` 以及 `mget` ）都接受一个叫做 `routing` 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。

## 主分片和副本分片如何交互
假设有一个三个节点的集群，包含一个叫 `blogs` 的索引。有两个主分片和四个副分片。
则分片的分布可能如图：

![图片]({{ "/assets/images/elas_0401.png" }})

我们假设下面的请求，都发送到 `Node 1` 上。

## 新建、索引和删除文档
新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。

> 一个文档只能存在于一个分片中，也就是说，如果一个索引有两个主分片，可以认为两个主分片合起来存储了索引的所有文档。

更新步骤：
![图片]({{ "/assets/images/elas_0402.png" }})

1. 客户端向 `Node 1` 发送新建、索引或者删除请求。
2. 节点使用文档的 `_id` 确定文档属于分片 0 。请求会被转发到` Node 3`，因为分片 0 的主分片目前被分配在 `Node 3` 上。
3. `Node 3` 在主分片上面执行请求。如果成功了，它将请求并行转发到 `Node 1` 和 `Node 2` 的副本分片上。一旦所有的副本分片都报告成功, `Node 3` 将向协调节点报告成功，协调节点向客户端报告成功。

在客户端收到成功响应时，文档变更**已经在主分片和所有副本分片执行完成**，变更是安全的。

一些可选参数：

`consistency`：consistency，即一致性。

> 在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 _规定数量(quorum)_（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写_操作(其中分片副本可以是主分片或者副本分片)。
> \_规定数量\_ 计算公式: `int( (primary + number_of_replicas) / 2 ) + 1`

`consistency` 参数的值可以设为 `one` （只要主分片状态 ok 就允许执行_写_操作）,`all`（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作）, 或 `quorum` 。默认值为 `quorum` , 即大多数的分片副本状态没问题就允许执行_写_操作。

`timeout`

如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 timeout 参数 使它更早终止： 100 100毫秒，30s 是30秒。

## 取回一个文档
![图片]({{ "/assets/images/elas_0403.png" }})

1. 客户端向 `Node 1` 发送获取请求。
2. 节点使用文档的 `_id` 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 `Node 2 `。
3. `Node 2` 将文档返回给 Node 1 ，然后将文档返回给客户端。

## 局部更新文档
![图片]({{ "/assets/images/elas_0404.png" }})

1. 客户端向 `Node 1` 发送更新请求。
2. 它将请求转发到主分片所在的 `Node 3` 。
3. `Node 3` 从主分片检索文档，修改 `_source` 字段中的 `JSON` ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 `retry_on_conflict` 次后放弃。
4. 如果 `Node 3` 成功地更新文档，它将新版本的文档并行转发到 `Node 1` 和 `Node 2` 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， `Node 3` 向协调节点也返回成功，协调节点向客户端返回成功。

> 当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。

## 多文档模式
协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。

协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。
![图片]({{ "/assets/images/elas_0405.png" }})

1. 客户端向 `Node 1` 发送 `mget` 请求。
2. `Node 1` 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，` Node 1` 构建响应并将其返回给客户端。

同时，可以对 docs 数组中每个文档设置 routing 参数。

![图片]({{ "/assets/images/elas_0406.png" }})
1. 客户端向 `Node 1` 发送 `bulk` 请求。
2. `Node 1` 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。
3. 主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。
