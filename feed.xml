<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-03T20:04:34+08:00</updated><id>http://localhost:4000/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">Basic Concept of Elasticsearch</title><link href="http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html" rel="alternate" type="text/html" title="Basic Concept of Elasticsearch" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch</id><content type="html" xml:base="http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html">&lt;p&gt;Elasticsearch 中的几个基本概念&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Near Realtime(NRT)&lt;/strong&gt;：接近实时，意味着，当你将内容存储到 Elasticsearch 后，大概最多一秒钟后就可以搜索了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：集群是一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;，并且在此基础上提供索引与搜索等功能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 就是一个集群中的单台服务器，它存储数据，参与整个集群的数据索引和搜索功能。一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 在启动时会加入到指定的集群中去。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是一组有特定属性的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Documents&lt;/code&gt;。比如，你可以有个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放客户数据的，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放产品目录。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：对于一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;，你可以指定一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，你自己可以赋予它任何意义。一般来说，比如多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 有相同的几个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;，那么它们可以认为是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 是能够被索引的基本单元。比如，一个客户有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shards &amp;amp; Replicas&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 存储的数据可能会非常庞大， 以至于单台机器并没有办法存放这些数据。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt;：为了解决这个问题，所以引入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 来将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 分成多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt;，每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 可以认为是一个独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;。我们在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 时，可以指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的数量。&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 提供了以下两个主要功能：
        &lt;ul&gt;
          &lt;li&gt;可以将你的内容平行分割扩展&lt;/li&gt;
          &lt;li&gt;可以提供分布式并行操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的管理完全由 Elasticsearch 接手。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Replica&lt;/strong&gt;：任何系统都需要有失败恢复机制。而 &lt;strong&gt;Replica&lt;/strong&gt; 或者 &lt;strong&gt;Replica Shard&lt;/strong&gt; 就提供这样的功能，它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的备份。它提供两个主要功能。
        &lt;ul&gt;
          &lt;li&gt;当一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard/Node&lt;/code&gt; 出错时，依然可以保持功能完整。所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;Replica&lt;/code&gt; 与 原 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 永远不会存放在同一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 上面。&lt;/li&gt;
          &lt;li&gt;它可以帮助扩展你的搜索数据量，因为所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 都会被搜索到。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 中的几个基本概念</summary></entry><entry><title type="html">Chapter 2 - Lexical Analysis</title><link href="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html" rel="alternate" type="text/html" title="Chapter 2 - Lexical Analysis" /><published>2018-04-26T00:00:00+08:00</published><updated>2018-04-26T00:00:00+08:00</updated><id>http://localhost:4000/compiler/2018/04/26/lexical-analysis</id><content type="html" xml:base="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html">&lt;p&gt;『Modern Compiler Implementation in C』词法分析部分笔记和总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;lex-i-cal&lt;/strong&gt; : of or relating to words or the vocabulary of a language as distinguished from its grammar and construction&lt;/p&gt;

  &lt;p&gt;— Webster’s Dictionary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要将程序从一种语言翻译到另一种语言，编译器要先将程序处理成&lt;strong&gt;片段&lt;/strong&gt;，并理解其&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;意义&lt;/strong&gt;，然后将片段重新再组合。编译器前端负责&lt;strong&gt;分析&lt;/strong&gt;，而后端负责&lt;strong&gt;整合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;分析工作主要:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析（Lexical analysis）：将输入识别成词素，既（Lexical Token）&lt;/li&gt;
  &lt;li&gt;语法分析（Syntax analysis）：分析程序的结构&lt;/li&gt;
  &lt;li&gt;语义分析（Semantic analysis）：计算出程序的意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;词法分析器输入字符流，输出词，关键字，符号等。&lt;/p&gt;

&lt;h2 id=&quot;lexical-tokens词素&quot;&gt;LEXICAL TOKENS（词素）&lt;/h2&gt;
&lt;p&gt;Lexical token 是一个字符序列，它是一门语言的最小语法元素。一门编程语言的 token 类型，是一个有限集合。&lt;/p&gt;

&lt;h3 id=&quot;例如&quot;&gt;例如：&lt;/h3&gt;

&lt;p&gt;Token 类型 例子&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; foo n14, last&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NUM&lt;/code&gt; 74 0 00 082&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;REAL&lt;/code&gt; 66.1 .5 10. 1e66 5.5e-10&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; if&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; ,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NOTEQ&lt;/code&gt; !=&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; (&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 if，void，这样的符号，我们称之为&lt;strong&gt;保留字&lt;/strong&gt;，在大部分语言里，保留字不能作为 ID 来使用。除了上面这些 Token 以外，字符流中还有非 token 内容。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注释  /* try again */&lt;/li&gt;
  &lt;li&gt;预处理 #include &lt;stdio.h&gt;&lt;/stdio.h&gt;&lt;/li&gt;
  &lt;li&gt;预处理 #define NUMS 5 , 6&lt;/li&gt;
  &lt;li&gt;宏 NUMS&lt;/li&gt;
  &lt;li&gt;空格，换行，缩进等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弱语言需要有一个宏预处理器，宏预处理去先操作输入流，进行预处理，生成新的字符流输出给词法分析器。当然，也可以直接将宏预处理器集成到词法分析器中去。&lt;/p&gt;

&lt;p&gt;比如有这样一段代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* find a zero */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;match0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;词法分析器在输入这段代码后，会输出：
&lt;code class=&quot;highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(match0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;BANG&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CHAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(strncmp)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RETURN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;REAL(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;NUM(3)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SEMI&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;EOF&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从上面的输出我们可以看到，每一个输出的 Token 都有类型。其中，像 &lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING&lt;/code&gt; 等会带有值来提供额外的信息。&lt;/p&gt;

&lt;p&gt;那么，接下来的问题是，我们用什么来描述 Token 的规则？用什么语言来实现词法分析器？我们完全可以使用自然语言来直接描述规则，比如下面这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;标识符（ID）&lt;/code&gt;是由字母和数字组成的字符序列，首个字符必须是字母开头。同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 下划线也认为是字母。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时,我们也可以使用任意合适的语言去实现词法分析器。不过，在这里，我们会使用&lt;strong&gt;正则表达式&lt;/strong&gt;来描述词法规则，用&lt;strong&gt;确定性有限自动机&lt;/strong&gt;来实现，同时，还会使用&lt;strong&gt;数学语言&lt;/strong&gt;来将这两者联系起来。&lt;/p&gt;

&lt;h2 id=&quot;regular-expression正则表达式&quot;&gt;REGULAR EXPRESSION（正则表达式）&lt;/h2&gt;
&lt;p&gt;一门语言，是一个字符串的集合；字符串是符号的有限序列；符号来自一个优先符号集合。我们这样描述一门语言时，并没有赋予字符串以任何意义，我们只是去区分字符串是否属于这门语言。为了能够仅仅使用有限的规则来描述一门语言，我们使用&lt;strong&gt;正则表达式&lt;/strong&gt;来标记这些规则。每一条&lt;strong&gt;正则表达式&lt;/strong&gt;表示一组字符串。&lt;/p&gt;

&lt;p&gt;下面是正则表达式的基本规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Symbol（符号）&lt;/strong&gt;：对于每一个符号 &lt;strong&gt;a&lt;/strong&gt; ，直接表示字符串 &lt;strong&gt;a&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Alternation（选择）&lt;/strong&gt;：对于 $M \mid N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Concatenation（连续，连接）&lt;/strong&gt;：$M \ast N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Epsilon（空）&lt;/strong&gt;：$\epsilon$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Repetition（重复）&lt;/strong&gt;：重复一次，重复多次，至少重复一次&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kleene closure: Given a regular expression M, its Kleene closure is $M^*$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用以上这些基本规则，我们就可以来表示由 ASCII 字符组成的变成语言了。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(0 \mid 1)^\ast \ast 0$ 表示任意能被 2 整除的二进制数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$ : 普通字符&lt;/li&gt;
  &lt;li&gt;$\epsilon$ : 空字符串&lt;/li&gt;
  &lt;li&gt;$M \mid N$ : 选择 M 或 N&lt;/li&gt;
  &lt;li&gt;$M \bullet N$ (MN) : 连接&lt;/li&gt;
  &lt;li&gt;$M^\ast$ : 重复出现零次或多次&lt;/li&gt;
  &lt;li&gt;$M^+$ : 重复出现一次或多次&lt;/li&gt;
  &lt;li&gt;$M?$ : 出现一次或者不出现&lt;/li&gt;
  &lt;li&gt;$[a-zA-Z]$: 再大小写字母中选择&lt;/li&gt;
  &lt;li&gt;$\bullet$ : 表示任意字符&lt;/li&gt;
  &lt;li&gt;“$a.+^\ast$” : 精确匹配完成字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入正则表达式后，我们就可以来描述词法规则了&lt;/p&gt;

&lt;p&gt;假如有下面这样的 C 代码片段：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* do nothing */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有关键字 &lt;strong&gt;if&lt;/strong&gt;，标识符 &lt;strong&gt;ID&lt;/strong&gt;，数字 &lt;strong&gt;NUM&lt;/strong&gt;，以及实数 &lt;strong&gt;REAL&lt;/strong&gt;，还定义了注释 『–』开头的单行注释。第五行是注释，意味着词法分析器会跳过它们继续执行，同时，词法分析器应该是功能完整的。它应该能够处理所有的符号，包括错误的。&lt;/p&gt;

&lt;p&gt;写到这里，我们很快会注意到一个问题：&lt;strong&gt;IF&lt;/strong&gt; 和 &lt;strong&gt;ID&lt;/strong&gt; 这两个规则是有交集的。在没有假如更多规则的情况下，我们如何去识别 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 到底是 &lt;strong&gt;ID token&lt;/strong&gt; 还是 &lt;strong&gt;IF token&lt;/strong&gt;？再比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是先匹配 &lt;strong&gt;IF&lt;/strong&gt; 规则还是先匹配 &lt;strong&gt;ID&lt;/strong&gt; 规则？&lt;/p&gt;

&lt;p&gt;下面引入两种常用的去歧义规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Longest match&lt;/strong&gt;：也就是最长匹配原则，规则所能匹配的最长子串作为下一个输出的 token。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rule priority&lt;/strong&gt;：规则优先级原则，对于一个最长子串，第一个能够匹配的规则所表示 token 作为输。这也就意味着，匹配的顺序是有意义且重要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入了这两个规则之后，我们就可以确定 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 是 &lt;strong&gt;IF&lt;/strong&gt; token 了，因为它最新匹配了 &lt;strong&gt;IF&lt;/strong&gt;，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是 &lt;strong&gt;ID&lt;/strong&gt; token.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;好了，到这里可以先简单的做一下总结。一门语言，有其最基本的语法元素，这里是 Lexical token。我们需要描述每一种 token 的规则，当然可以使用自然语言，但要让 Lexer 理解，必须要使用一种能实现成程序的方式。
于是我们引入了 Regular Expression 来描述词法规则。同时付加了两条消除歧义的规则，&lt;strong&gt;最长匹配&lt;/strong&gt;和&lt;strong&gt;匹配优先级&lt;/strong&gt;
那么，到这里我有一个疑问，&lt;strong&gt;是不是使用 Regular Expression 就足够实现词法分析了？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finite-automata&quot;&gt;FINITE AUTOMATA&lt;/h2&gt;

&lt;p&gt;前面有个问题：有了&lt;strong&gt;正则表达式&lt;/strong&gt;，是不是就可以直接使用&lt;strong&gt;正则&lt;/strong&gt;来实现词法匹配了？毕竟大多数的语言都有&lt;strong&gt;正则&lt;/strong&gt;的实现。对的，用正则来实现词法分析器是完全没有问题的。&lt;/p&gt;

&lt;p&gt;这里我正好在网上搜到了 Rob Pike 一篇文章 &lt;a href=&quot;https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html&quot;&gt;Regular expression in lexing and parsing&lt;/a&gt;。摘取他的观点放在这里。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are hard to write, hard to write well, and can be expensive relative to other technologies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A regular expression library is a big thing. Using one to parse identifiers is like using a Mack truck to go to the store for milk. And when we want to adjust our lexer to admit other character types, such as Unicode identifiers, and handle normalization, and so on, the hand-written loop can cope easily but the regexp approach will break down.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Using regular expressions to explore the parse state to find the way forward is expensive, overkill, and error-prone.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are, in my experience, widely misunderstood and abused.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们这里，是使用有限自动&lt;/p&gt;

&lt;h3 id=&quot;什么是有限自动机&quot;&gt;什么是有限自动机？&lt;/h3&gt;

&lt;p&gt;有限自动机是一种状态机，它通过状态转化来实现接受或者拒绝特定字符串的功能。&lt;/p&gt;

&lt;p&gt;这里就摘取维基百科对于状态机的定义&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;About this image
Classes of automata
(Clicking on each layer will take you to an article on that subject)
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types - deterministic finite state machines and non-deterministic finite state machines.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The finite state machine has less computational power than some other models of computation such as the Turing machine.[2] The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM’s memory is limited by the number of states it has. FSMs are studied in the more general field of automata theory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，现在引入了有限自动机这个概念。
有限自动机可以很方便的是现成程序。
有限自动机由：&lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边（从一个状态到另一个状态）&lt;/strong&gt;，&lt;strong&gt;边上的符号&lt;/strong&gt;，&lt;strong&gt;开始状态&lt;/strong&gt; 和 &lt;strong&gt;终结状态&lt;/strong&gt; 组成。&lt;/p&gt;

&lt;p&gt;有限自动机分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA 确定性有限自动机：从一个状态接收，只有唯一确定的边指向另一个状态。&lt;/li&gt;
  &lt;li&gt;NFA 非确定性有限自动机：从一个状态接收，有多个不同的状态可以到达。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我们可以给上面的词法规则画出如下的几个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_1.png&quot; alt=&quot;Fig 2.3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们也可以写成一个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_2.png&quot; alt=&quot;Fig 2.4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;EXERCISES&lt;/h2&gt;

&lt;p&gt;2.1 Write regular expressions for each of the following.&lt;/p&gt;

&lt;p&gt;a. String over the alphabet $ \{ a,b,c \} $ where the first $a$ precedes the first $b$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：因为必须第一个 $a$ 出现在第一个 $b$ 后面，所以实际上只有两种情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;第一个 $a$ 前面只有 $c$&lt;/li&gt;
    &lt;li&gt;没有出现 $a$&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ c^\ast a[abc]^\ast \mid [bc]^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;b. String over the alphabet {a,b,c} with an even number of a’s.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：需要 $a$ 的个数是偶数个
同样也分解情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;两个 $a$ 连续出现&lt;/li&gt;
    &lt;li&gt;两个 $a$ 没有连续出现，中间有其他字符&lt;/li&gt;
    &lt;li&gt;可以为空
将上面的三种情况组合起来，得到答案&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ (a([bc]^\ast aa[bc]^\ast )^\ast a)^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;c. Binary numbers that are multiples of four.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$0\mid1^\ast00$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;d. Binary numbers that are greater than 101001.&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;e. String over the alphabet {a,b,c} that don’t contain the contiguous string baa.&lt;/p&gt;

&lt;p&gt;f. The language of nonnegative integer constants in C, where numbers beginning with 0 are octal constants and other numbers are decimal constants.&lt;/p&gt;

&lt;p&gt;g. Binary numbers n such that there exists an integer solution of $a^n + b^n = c^n$.&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">『Modern Compiler Implementation in C』词法分析部分笔记和总结。</summary></entry><entry><title type="html">Notes on Machine Learning on Coursera</title><link href="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html" rel="alternate" type="text/html" title="Notes on Machine Learning on Coursera" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera</id><content type="html" xml:base="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html">&lt;p&gt;I always want to learn Machine Learning and finally I got time.&lt;/p&gt;

&lt;p&gt;I first started with the open class CS 229 Machine Learning from Stanford by Andrew Ng. But I failed after 2 classes, because Andrew Ng skipped some math detail that I forget the knowledge of calculus and linear algebra.&lt;/p&gt;

&lt;p&gt;Then I find the Machine Learning by Andrew Ng on &lt;a href=&quot;http://www.coursera.com/&quot;&gt;Coursera&lt;/a&gt; is great.&lt;/p&gt;

&lt;p&gt;The learning curve of class is more gentle, and all math details are covered in the course.&lt;/p&gt;

&lt;p&gt;So if you want to learning machine learning, I highly recommend you try this course. All you want to know is the basic knowledge of calculus and linear algebra, which also covered in the course.&lt;/p&gt;

&lt;p&gt;Yeah!&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">I always want to learn Machine Learning and finally I got time.</summary></entry><entry><title type="html">《头号玩家》</title><link href="http://localhost:4000/2018/04/02/ready-player-one.html" rel="alternate" type="text/html" title="《头号玩家》" /><published>2018-04-02T00:00:00+08:00</published><updated>2018-04-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/02/ready-player-one</id><content type="html" xml:base="http://localhost:4000/2018/04/02/ready-player-one.html">&lt;p&gt;看完《头号玩家》后，有一个问题一直在脑海里盘旋：
『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』&lt;/p&gt;

&lt;p&gt;到刚才，在微博上看到梅原大吾用隆完全格挡春丽的大招时，我才忽然明白。&lt;/p&gt;

&lt;p&gt;《头号玩家》带给我的感觉：&lt;/p&gt;

&lt;p&gt;它瞬间把我拉回了童年，那个在一群人在家里，围着游戏机一起通关的场景。&lt;/p&gt;

&lt;p&gt;之所以喜悦是因为那种久违的感觉，而忧伤是，你知道永远也不会再回去了。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">看完《头号玩家》后，有一个问题一直在脑海里盘旋： 『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』</summary></entry><entry><title type="html">My New Rules of Life</title><link href="http://localhost:4000/2018/03/02/my-new-rules-of-life.html" rel="alternate" type="text/html" title="My New Rules of Life" /><published>2018-03-02T13:56:00+08:00</published><updated>2018-03-02T13:56:00+08:00</updated><id>http://localhost:4000/2018/03/02/my-new-rules-of-life</id><content type="html" xml:base="http://localhost:4000/2018/03/02/my-new-rules-of-life.html">&lt;h4 id=&quot;things-i-wont-do-in-the-future&quot;&gt;Things I won’t do in the future&lt;/h4&gt;

&lt;p&gt;1 Alchohol.&lt;/p&gt;

&lt;p&gt;2 Eating meat except chicken and fish.&lt;/p&gt;

&lt;p&gt;3 Cigarette.&lt;/p&gt;

&lt;p&gt;4 Fast food, sugure, carbonated soft drinks.&lt;/p&gt;

&lt;h4 id=&quot;things-i-want&quot;&gt;Things I want&lt;/h4&gt;

&lt;p&gt;1 Exercises.&lt;/p&gt;

&lt;p&gt;2 Sleep early and get up early.&lt;/p&gt;

&lt;p&gt;3 Reading.&lt;/p&gt;</content><author><name></name></author><summary type="html">Things I won’t do in the future</summary></entry><entry><title type="html">两部电影和下一步</title><link href="http://localhost:4000/2018/01/10/recent.html" rel="alternate" type="text/html" title="两部电影和下一步" /><published>2018-01-10T00:15:00+08:00</published><updated>2018-01-10T00:15:00+08:00</updated><id>http://localhost:4000/2018/01/10/recent</id><content type="html" xml:base="http://localhost:4000/2018/01/10/recent.html">&lt;p&gt;最近看了两部有意思的电影。《一日情人》和《三块广告牌》。&lt;/p&gt;

&lt;p&gt;《一日情人》是一部法国电影。工作后，就一直没有心思停下来看这样“絮絮叨叨”的电影了，好像，电影里所探讨的问题，琐碎得遥远。&lt;/p&gt;

&lt;p&gt;7 分吧，推荐喜欢这类电影的人看一看。&lt;/p&gt;

&lt;p&gt;这里放上几张好看的剧照：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2457077051.jpg&quot; alt=&quot;剧照1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2457077066.jpg&quot; alt=&quot;剧照2&quot; /&gt;
&lt;img src=&quot;/assets/images/p2494758206.jpg&quot; alt=&quot;剧照3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而另一部电影《三块广告牌》，则是刚刚过去的75届金球奖最佳剧情片得主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2510412903.jpg&quot; alt=&quot;海报1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2510431925.jpg&quot; alt=&quot;剧照1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部电影的剧情结构让我想起了几年前看的《Crash》。多个人物之间的冲突，以及人物，情节与大环境之间的相互影响，都像极了《Crash》。&lt;/p&gt;

&lt;p&gt;9 分推荐。&lt;/p&gt;

&lt;p&gt;同一位导演我还看过另一部作品《在布鲁日》（又名《杀手没有假期》），当时没有看得太明白，只是觉得非常有意思。&lt;/p&gt;

&lt;p&gt;关于我的下一步。在考虑了几天之后，我决定正式接受老陆的工作，完成 DearID 的项目。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">最近看了两部有意思的电影。《一日情人》和《三块广告牌》。</summary></entry><entry><title type="html">时间</title><link href="http://localhost:4000/2018/01/03/time.html" rel="alternate" type="text/html" title="时间" /><published>2018-01-03T23:05:00+08:00</published><updated>2018-01-03T23:05:00+08:00</updated><id>http://localhost:4000/2018/01/03/time</id><content type="html" xml:base="http://localhost:4000/2018/01/03/time.html">&lt;p&gt;对于一个人而言，过去的生活到底意味着什么？时间又是什么？&lt;/p&gt;

&lt;p&gt;2016 年我失去了一位很重要的亲人，但是现在去回忆，当时所有的痛苦都变得平淡了。那么，那些原本经历的事情最后变成了什么？&lt;/p&gt;

&lt;p&gt;时间不是连续的，因为人的大脑和经验不是连续的。时间一旦消失，人对于时间的感知就消失了。反过来也可以认为，对于未来时间的感知实际上也是虚假的。如果我们迫切的希望眼前的时间快速的过去，那意味着对于即将到来的事情而言，此时此刻是不重要的。&lt;/p&gt;

&lt;p&gt;但是，如果此时此刻是不重要的，那为什么即将到来的事情是重要的？我的意思是，为什么可以不在乎此时此刻而更加在乎即将到来的事情？&lt;/p&gt;

&lt;p&gt;但是，假设一种极端情况，如果24小时后我要被枪决，或者我知道自己的生命只剩几个月了。也就是说，将要到来的一件事，不只是非常重要，而是直接结束了一切。那么，此时此刻还重要吗？我以什么样的方式过，做什么事情还重要吗？如果不重要，为什么50年就是重要的？因为时间的长度吗？&lt;/p&gt;

&lt;p&gt;我已经坚信一个结论：时间的长度本身是不重要的。50年和50天之间的区别只在于这段时间内做的事情。如果 50 天我去了马丘比丘，去了埃及，去了复活节岛。而 50 年里，我追求安全感的生活让我什么都没做，想去的地方，想做的事情一件也没有达成。那显然我会选择 50 天。&lt;/p&gt;

&lt;p&gt;但我并不是要去藐视时间，觉得时间（生命）是不重要的，我太希望那位离开的亲人活得更久一点了。&lt;/p&gt;

&lt;p&gt;时间好像是一种介质，它将我们（做的事情，经历）与（我们的）生活联系起来，从而赋予（我们的）生命以意义。所以，“怎么利用时间？”这个问题的重点其实是，在时间中我们做什么？因为时间是没有办法控制的，无论我们做什么，做多做少，时间最后都会消失，能控制的只是“做什么”。&lt;/p&gt;

&lt;p&gt;所以，“现在做什么”比什么都重要。&lt;/p&gt;

&lt;p&gt;下一个问题：怎么决定“现在做什么”？&lt;/p&gt;

&lt;p&gt;前两天看到了贝索斯在亚马逊早起的一个采访。当时亚马逊应该已经是一个有所成就的图书销售网站了，所以，贝索斯可以认为是一个成功的人了，至少再外界看来。所以，在采访中，主持人问贝索斯说，“我以为你会是一个享受当下的人”。贝索斯非常干脆的回答了这个问题，说他不是这样的人，他做事遵循的原则是，“最小后悔原则”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;，这个词我是第一次听说，当然，一听到就觉得非常有道理。&lt;/p&gt;

&lt;p&gt;但是随之而来产生了几个疑问是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;的目标是什么？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从采访中，可以看出，至少贝索斯认为现在虽然已经是还算成功的状态了，但是在他能看到的地方，还有更重要的事情去做。所以，为了达到这个目的，此时此刻，享受当下是非常愚蠢的。&lt;/p&gt;

&lt;p&gt;所以，要能看到“未来”。要大概的知道“未来”的样子，然后为之制定一套行为标准，其实并不需要清晰的知道“未来”，因为谁也不可能清楚的预测。但是，通过想象未来的样子，可以看到方向。比如，我并不知道未来具体是什么情景，但是大概知道我想要去日本，所以现在开始学好日语就是一条&lt;strong&gt;最小后悔原则&lt;/strong&gt;。其实，另一个问题也有了：&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？那就是在此时此刻尽力了。&lt;/p&gt;

&lt;p&gt;但是这个“尽力”并不是精疲力劲的意思，精疲力劲实际上意味着透支未来，以一种低效的方式去话费未来的时间。尽力，可以认为是相对努力，已目前能达到的最大状态工作，但又不至于过于疲惫。&lt;/p&gt;

&lt;p&gt;所以，决定“此时此刻”的是未来，但创造未来的，确实“此时此刻”。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">对于一个人而言，过去的生活到底意味着什么？时间又是什么？</summary></entry><entry><title type="html">Deathland Studio 开张</title><link href="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html" rel="alternate" type="text/html" title="Deathland Studio 开张" /><published>2018-01-01T15:26:33+08:00</published><updated>2018-01-01T15:26:33+08:00</updated><id>http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio</id><content type="html" xml:base="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html">&lt;p&gt;今天 2018 年的第一天，Deathland Studio 工作室正式成立。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/deathland_studio_logo.jpeg&quot; alt=&quot;Logo&quot; /&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">今天 2018 年的第一天，Deathland Studio 工作室正式成立。</summary></entry><entry><title type="html">Mac Root Bug</title><link href="http://localhost:4000/mac/2017/12/07/mac-root-bug.html" rel="alternate" type="text/html" title="Mac Root Bug" /><published>2017-12-07T10:11:00+08:00</published><updated>2017-12-07T10:11:00+08:00</updated><id>http://localhost:4000/mac/2017/12/07/mac-root-bug</id><content type="html" xml:base="http://localhost:4000/mac/2017/12/07/mac-root-bug.html">&lt;p&gt;前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;现象&quot;&gt;现象&lt;/h3&gt;

&lt;p&gt;这个漏洞的现象是：在任何地方需要管理员授权时，输入 root 用户名，密码为空，连续输入三次后，就获得了 root 权限。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;修改 root 密码的方法，参看这篇 Apple 的&lt;a href=&quot;https://support.apple.com/kb/PH6515?locale=zh_CN&amp;amp;viewlocale=zh_CN&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。</summary></entry><entry><title type="html">塞尔达传说-荒野之息 第一部分</title><link href="http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1.html" rel="alternate" type="text/html" title="塞尔达传说-荒野之息 第一部分" /><published>2017-12-05T10:11:00+08:00</published><updated>2017-12-05T10:11:00+08:00</updated><id>http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1</id><content type="html" xml:base="http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1.html">&lt;p&gt;在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。&lt;/p&gt;

&lt;p&gt;不过，在玩了几十个小时候，我还是决定收回这句疯狂的赞美，把它列为：最近几年来最让我投入的游戏。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;我一直偏爱 RPG 以及 开放世界。最早震撼我的游戏是《侠盗猎车手 — 罪恶都市》，
当年可以驾驶各种车辆穿梭在虚拟城市里的自由深深吸引了我，我想驾驶车辆驶过每一条马路，
想进入每一个可以进入的角落，想和每一个虚拟人物交谈，想进入每一座房子。&lt;/p&gt;

&lt;p&gt;但是，一个开放世界，最大的问题是无论我们花费多少时间去补充游戏的内容，只要玩家遇到一个地方无法通过，或者逻辑上的错误，那种开放世界的真实感就会土崩瓦解。
所以，目前的技术来说，做出一个完全真实的开放世界，几乎是不可能。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。</summary></entry></feed>