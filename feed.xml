<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://www.teslalee.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.teslalee.com/" rel="alternate" type="text/html" /><updated>2018-05-09T15:54:20+08:00</updated><id>http://www.teslalee.com/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 4</title><link href="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 4" /><published>2018-05-08T19:03:50+08:00</published><updated>2018-05-08T19:03:50+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4.html">&lt;p&gt;分布式文档存储&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;路由一个文档到一个分片中&quot;&gt;路由一个文档到一个分片中&lt;/h2&gt;
&lt;p&gt;当索引一个文档的时候，文档会被存储到一个主分片中。&lt;/p&gt;

&lt;p&gt;如何决定存储在哪个分片中？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shard = hash(routing) % number_of_primary_shards&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 &lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt; 函数生成一个数字，然后这个数字再除以 &lt;code class=&quot;highlighter-rouge&quot;&gt;number_of_primary_shards&lt;/code&gt; （主分片的数量）后得到 余数 。&lt;/p&gt;

&lt;p&gt;所有的文档 API（ &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;bulk&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;mget&lt;/code&gt; ）都接受一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。&lt;/p&gt;

&lt;h2 id=&quot;主分片和副本分片如何交互&quot;&gt;主分片和副本分片如何交互&lt;/h2&gt;
&lt;p&gt;假设有一个三个节点的集群，包含一个叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;blogs&lt;/code&gt; 的索引。有两个主分片和四个副分片。
则分片的分布可能如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0401.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们假设下面的请求，都发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 上。&lt;/p&gt;

&lt;h2 id=&quot;新建索引和删除文档&quot;&gt;新建、索引和删除文档&lt;/h2&gt;
&lt;p&gt;新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个文档只能存在于一个分片中，也就是说，如果一个索引有两个主分片，可以认为两个主分片合起来存储了索引的所有文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更新步骤：
&lt;img src=&quot;/assets/images/elas_0402.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送新建、索引或者删除请求。&lt;/li&gt;
  &lt;li&gt;节点使用文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 确定文档属于分片 0 。请求会被转发到&lt;code class=&quot;highlighter-rouge&quot;&gt; Node 3&lt;/code&gt;，因为分片 0 的主分片目前被分配在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 上。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 在主分片上面执行请求。如果成功了，它将请求并行转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 的副本分片上。一旦所有的副本分片都报告成功, &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 将向协调节点报告成功，协调节点向客户端报告成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在客户端收到成功响应时，文档变更&lt;strong&gt;已经在主分片和所有副本分片执行完成&lt;/strong&gt;，变更是安全的。&lt;/p&gt;

&lt;p&gt;一些可选参数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;consistency&lt;/code&gt;：consistency，即一致性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 &lt;em&gt;规定数量(quorum)&lt;/em&gt;（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写_操作(其中分片副本可以是主分片或者副本分片)。
_规定数量_ 计算公式: &lt;code class=&quot;highlighter-rouge&quot;&gt;int( (primary + number_of_replicas) / 2 ) + 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;consistency&lt;/code&gt; 参数的值可以设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;one&lt;/code&gt; （只要主分片状态 ok 就允许执行_写_操作）,&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作）, 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;quorum&lt;/code&gt; 。默认值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;quorum&lt;/code&gt; , 即大多数的分片副本状态没问题就允许执行_写_操作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 timeout 参数 使它更早终止： 100 100毫秒，30s 是30秒。&lt;/p&gt;

&lt;h2 id=&quot;取回一个文档&quot;&gt;取回一个文档&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0403.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送获取请求。&lt;/li&gt;
  &lt;li&gt;节点使用文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2 &lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 将文档返回给 Node 1 ，然后将文档返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;局部更新文档&quot;&gt;局部更新文档&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0404.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送更新请求。&lt;/li&gt;
  &lt;li&gt;它将请求转发到主分片所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 从主分片检索文档，修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;_source&lt;/code&gt; 字段中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 &lt;code class=&quot;highlighter-rouge&quot;&gt;retry_on_conflict&lt;/code&gt; 次后放弃。&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 成功地更新文档，它将新版本的文档并行转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 向协调节点也返回成功，协调节点向客户端返回成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Tesla Lee</name></author><summary type="html">分布式文档存储</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 3</title><link href="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 3" /><published>2018-05-08T15:09:15+08:00</published><updated>2018-05-08T15:09:15+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3.html">&lt;p&gt;数据输入和输出&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;一个 对象 是基于特定语言的内存的数据结构。 为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。 JSON 是一种以人可读的文本表示对象的方法。 它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 JSON 文档 。&lt;/p&gt;

&lt;p&gt;Elastcisearch 是分布式的 文档 存储。它能存储和检索复杂的数据结构–序列化成为JSON文档–以 实时 的方式。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;/p&gt;

&lt;p&gt;在 Elasticsearch 中， 每个字段的所有数据 都是 默认被索引的 。 即每个字段都有为了快速检索设置的专用倒排索引。&lt;/p&gt;

&lt;h2 id=&quot;什么是文档&quot;&gt;什么是文档？&lt;/h2&gt;

&lt;p&gt;我们使用的术语 对象 和 文档 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，术语 文档 有着特定的含义。它是指&lt;strong&gt;最顶层&lt;/strong&gt;或者&lt;strong&gt;根对象&lt;/strong&gt;, 这个根对象被&lt;strong&gt;序列化成 JSON&lt;/strong&gt;并存储到 Elasticsearch 中，指定了唯一 ID。&lt;/p&gt;

&lt;h2 id=&quot;文档元数据&quot;&gt;文档元数据&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_index&lt;/code&gt;: 文档存放在那里&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_type&lt;/code&gt;: 文档表示的对象类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;: 文档唯一标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;_index&quot;&gt;_index&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;索引&lt;/code&gt;应该是因共同的特性被分组到一起的文档集合。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;_type&quot;&gt;_type&lt;/h3&gt;
&lt;p&gt;数据可能在索引中只是松散的组合在一起。Elasticsearch 公开了一个称为 types （类型）的特性，它允许您在索引中对数据进行逻辑分区。&lt;/p&gt;

&lt;h3 id=&quot;_id&quot;&gt;_id&lt;/h3&gt;
&lt;p&gt;ID 是一个字符串， 当它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。&lt;/p&gt;

&lt;h3 id=&quot;索引文档&quot;&gt;索引文档&lt;/h3&gt;
&lt;p&gt;通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; API ，文档可以被 索引 —— 存储和使文档可被搜索 。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;index&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;id&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;field&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;value&quot;&lt;/span&gt;,
  ...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用自己的-id&quot;&gt;使用自己的 ID&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Just trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;自增-id&quot;&gt;自增 ID&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My second blog entry&quot;,
  &quot;text&quot;:  &quot;Still trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;取回文档&quot;&gt;取回文档&lt;/h2&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123?pretty&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;返回&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;website&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;blog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;found&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_source&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;My first blog entry&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Just trying this out...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2014/01/01&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;返回文档的一部分&quot;&gt;返回文档的一部分&lt;/h3&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123?_source=title,text&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;检查文档是否存在&quot;&gt;检查文档是否存在&lt;/h2&gt;
&lt;p&gt;如果只想检查一个文档是否存在 –根本不想关心内容–那么用 HEAD 方法来代替 GET 方法。 HEAD 请求没有返回体，只返回一个 HTTP 请求报头：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;200&lt;/code&gt; 存在&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;404&lt;/code&gt; 不存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新整个文档&quot;&gt;更新整个文档&lt;/h2&gt;
&lt;p&gt;在 Elasticsearch 中文档是 不可改变 的，不能修改它们。如果想要更新现有的文档，需要 重建索引 或者进行替换。&lt;/p&gt;

&lt;p&gt;使用下面的命令&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;I am starting to get the hang of this...&quot;,
  &quot;date&quot;:  &quot;2014/01/02&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们看到文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 已经变成 2 ，说明文档更新成功了。但实际上是，将就得&lt;strong&gt;文档&lt;/strong&gt;标记为删除，同时新建了一个&lt;strong&gt;文档&lt;/strong&gt;。
更新一个文档时，Elasticsearch 内部的执行过程大概是&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从旧文档构建 JSON&lt;/li&gt;
  &lt;li&gt;更改该 JSON&lt;/li&gt;
  &lt;li&gt;删除旧文档&lt;/li&gt;
  &lt;li&gt;索引一个新文档&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建新文档&quot;&gt;创建新文档&lt;/h2&gt;
&lt;p&gt;当我们索引一个文档， 怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请记住， &lt;code class=&quot;highlighter-rouge&quot;&gt;_index&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;_type&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 的组合可以唯一标识一个文档。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /website/blog/
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自增 ID&lt;/p&gt;

&lt;p&gt;第一种方法使用 op_type 查询 -字符串参数：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /website/blog/123?op_type&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;create
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二种方法是在 URL 末端使用 /_create :&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /website/blog/123/_create
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。&lt;/p&gt;

&lt;p&gt;另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码。&lt;/p&gt;

&lt;h2 id=&quot;删除文档&quot;&gt;删除文档&lt;/h2&gt;
&lt;p&gt;删除文档 的语法和我们所知道的规则相同，只是 使用 DELETE 方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; DELETE &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果找到该文档，Elasticsearch 将要返回一个 200 ok 的 HTTP 响应码，如果文档没有 找到，我们将得到 404 Not Found 的响应码和类似这样的响应体。&lt;/p&gt;

&lt;p&gt;即使文档不存在（ Found 是 false ）， &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 值仍然会增加。&lt;/p&gt;

&lt;h2 id=&quot;处理冲突&quot;&gt;处理冲突&lt;/h2&gt;
&lt;p&gt;当我们使用 index API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 整个文档 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。&lt;/p&gt;

&lt;h3 id=&quot;悲观并发控制&quot;&gt;悲观并发控制&lt;/h3&gt;
&lt;p&gt;这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。&lt;/p&gt;

&lt;h3 id=&quot;乐观并发控制&quot;&gt;乐观并发控制&lt;/h3&gt;
&lt;p&gt;Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。&lt;/p&gt;

&lt;h2 id=&quot;乐观并发控制-1&quot;&gt;乐观并发控制&lt;/h2&gt;
&lt;p&gt;Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。&lt;/p&gt;

&lt;p&gt;Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。&lt;/p&gt;

&lt;p&gt;所有文档的更新或删除 API，都可以接受 version 参数，这允许你在代码中使用乐观的并发控制，这是一种明智的做法。&lt;/p&gt;

&lt;h3 id=&quot;通过外部系统使用版本控制&quot;&gt;通过外部系统使用版本控制&lt;/h3&gt;
&lt;p&gt;一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。&lt;/p&gt;

&lt;p&gt;如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。&lt;/p&gt;

&lt;p&gt;外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。&lt;/p&gt;

&lt;p&gt;外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。&lt;/p&gt;

&lt;h2 id=&quot;文档的部分更新&quot;&gt;文档的部分更新&lt;/h2&gt;
&lt;p&gt;在 更新整个文档 , 我们已经介绍过 更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 update API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;doc&quot; : {
      &quot;tags&quot; : [ &quot;testing&quot; ],
      &quot;views&quot;: 0
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用脚本部分更新文档那个&quot;&gt;使用脚本部分更新文档那个&lt;/h3&gt;
&lt;p&gt;脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source 。 例如，我们可以使用脚本来增加博客文章中 views 的数量：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.tags+=new_tag&quot;,
   &quot;params&quot; : {
      &quot;new_tag&quot; : &quot;search&quot;
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新的文档可能尚不存在&quot;&gt;更新的文档可能尚不存在&lt;/h3&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;upsert&lt;/code&gt; 参数&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/pageviews/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;,
   &quot;upsert&quot;: {
       &quot;views&quot;: 1
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新和冲突&quot;&gt;更新和冲突&lt;/h3&gt;
&lt;p&gt;检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 设法重新索引之前，来自另一进程的请求修改了文档。&lt;/p&gt;

&lt;p&gt;为了避免数据丢失， &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; API 在 检索 步骤时检索得到文档当前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 号，并传递版本号到 重建索引 步骤的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; 请求。 如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 号将不匹配，更新请求将会失败。&lt;/p&gt;

&lt;p&gt;设置参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;retry_on_conflict&lt;/code&gt; 来在发现冲突时重试更新操作。&lt;/p&gt;

&lt;h2 id=&quot;取回多个文档&quot;&gt;取回多个文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mget API 要求有一个 docs 数组作为参数，每个 元素包含需要检索文档的元数据， 包括 _index 、 _type 和 _id 。&lt;/li&gt;
  &lt;li&gt;如果想检索的数据都在相同的 _index 中（甚至相同的 _type 中），则可以在 URL 中指定默认的 /_index 或者默认的 /_index/_type 。&lt;/li&gt;
  &lt;li&gt;如果所有文档的 _index 和 _type 都是相同的，你可以只传一个 ids 数组，而不是整个 docs 数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 200 。事实上，即使请求 没有 找到任何文档，它的状态码依然是 200 –因为 mget 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 found 标记。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;代价较小的批量操作&quot;&gt;代价较小的批量操作&lt;/h2&gt;
&lt;p&gt;与 mget 可以使我们一次取回多个文档同样的方式， bulk API 允许在单个步骤中进行多次 create 、 index 、 update 或 delete 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;每行一定要以换行符(\n)结尾， 包括最后一行。&lt;/li&gt;
  &lt;li&gt;这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个完整的 bulk 操作：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/_bulk&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{ &quot;delete&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; }}
{ &quot;create&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; }}
{ &quot;title&quot;:    &quot;My first blog post&quot; }
{ &quot;index&quot;:  { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; }}
{ &quot;title&quot;:    &quot;My second blog post&quot; }
{ &quot;update&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot;, &quot;_retry_on_conflict&quot; : 3} }
{ &quot;doc&quot; : {&quot;title&quot; : &quot;My updated blog post&quot;} }
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。&lt;/strong&gt;这也意味着 bulk 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。&lt;/p&gt;

&lt;h3 id=&quot;多大是太大了&quot;&gt;多大是太大了？&lt;/h3&gt;
&lt;p&gt;整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。&lt;/p&gt;

&lt;p&gt;通过批量索引典型文档，并不断增加批量大小进行尝试。 当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。&lt;/p&gt;

&lt;p&gt;密切关注你的批量请求的物理大小往往非常有用，一千个 1KB 的文档是完全不同于一千个 1MB 文档所占的物理大小。 一个好的批量大小在开始处理后所占用的物理大小约为 5-15 MB。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">数据输入和输出</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 2</title><link href="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 2" /><published>2018-05-07T18:16:46+08:00</published><updated>2018-05-07T18:16:46+08:00</updated><id>http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2</id><content type="html" xml:base="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2.html">&lt;p&gt;集群内的原理&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。&lt;/p&gt;

&lt;p&gt;一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。&lt;/p&gt;

&lt;h2 id=&quot;空集群&quot;&gt;空集群&lt;/h2&gt;

&lt;p&gt;一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster.name&lt;/code&gt; 配置的节点组成， 它们共同承担数据和负载的压力。当一个节点被选举成为 主 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。主节点并不需要涉及到&lt;strong&gt;文档级别&lt;/strong&gt;的变更和搜索等操作。&lt;/p&gt;

&lt;p&gt;可以将请求发送到 集群中的任何节点 ，包括主节点。&lt;/p&gt;

&lt;h2 id=&quot;集群健康&quot;&gt;集群健康&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;集群健康&lt;/em&gt; ， 它在 status 字段中展示为 green 、 yellow 或者 red&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;green&lt;/code&gt;: 所有的主分片和副本分片都正常运行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yellow&lt;/code&gt;: 所有的主分片都正常运行，但不是所有的副本分片都正常运行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;red&lt;/code&gt;: 有主分片没能正常运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;添加索引&quot;&gt;添加索引&lt;/h2&gt;
&lt;p&gt;往 Elasticsearch 添加数据时需要用到 索引 —— 保存相关数据的地方。 索引实际上是指向一个或者多个物理 分片 的 逻辑命名空间 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个 分片 是一个底层的 工作单元 ，它仅保存了 全部数据中的一部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。&lt;/p&gt;

&lt;p&gt;一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。一个副本分片只是一个主分片的拷贝。&lt;/p&gt;

&lt;p&gt;在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。&lt;/p&gt;

&lt;h2 id=&quot;水平扩容&quot;&gt;水平扩容&lt;/h2&gt;
&lt;p&gt;分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;应对故障&quot;&gt;应对故障&lt;/h2&gt;
&lt;p&gt;我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。
所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">集群内的原理</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 1</title><link href="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 1" /><published>2018-05-07T16:50:10+08:00</published><updated>2018-05-07T16:50:10+08:00</updated><id>http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1</id><content type="html" xml:base="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1.html">&lt;p&gt;你知道的，为了搜索…
&lt;!--more--&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：&lt;/p&gt;

  &lt;p&gt;一个分布式的实时文档存储，每个字段 可以被索引与搜索
一个分布式实时分析搜索引擎
能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;与-elasticsearch-交互&quot;&gt;与 Elasticsearch 交互&lt;/h2&gt;

&lt;h3 id=&quot;java-客户端&quot;&gt;JAVA 客户端&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;节点客户端（Node client）
    &lt;ul&gt;
      &lt;li&gt;节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传输客户端（Transport client）
    &lt;ul&gt;
      &lt;li&gt;轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。&lt;/p&gt;

&lt;h3 id=&quot;rest-api&quot;&gt;REST API&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt;&amp;lt;VERB&amp;gt; &lt;span class=&quot;s1&quot;&gt;'&amp;lt;PROTOCOL&amp;gt;://&amp;lt;HOST&amp;gt;:&amp;lt;PORT&amp;gt;/&amp;lt;PATH&amp;gt;?&amp;lt;QUERY_STRING&amp;gt;'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&amp;lt;BODY&amp;gt;'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VERB&lt;/code&gt;: 适当的 HTTP 方法 或 谓词 : &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;PUT&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PROTOCOL&lt;/code&gt;: http 或者 https&lt;code class=&quot;highlighter-rouge&quot;&gt;（如果你在 Elasticsearch 前面有一个 &lt;/code&gt;https 代理）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HOST&lt;/code&gt;: Elasticsearch 集群中任意节点的主机名，或者用 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt; 代表本地机器上的节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PORT&lt;/code&gt;: 运行 Elasticsearch HTTP 服务的端口号，默认是 9200&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;: API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;_cluster/stats&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_nodes/stats/jvm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QUERY_STRING&lt;/code&gt;:&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BODY&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向文档&quot;&gt;面向文档&lt;/h2&gt;
&lt;p&gt;Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。&lt;/p&gt;

&lt;h2 id=&quot;demo-数据&quot;&gt;DEMO 数据&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;支持包含多值标签、数值、以及全文本的数据&lt;/li&gt;
  &lt;li&gt;检索任一雇员的完整信息&lt;/li&gt;
  &lt;li&gt;允许结构化搜索，比如查询 30 岁以上的员工&lt;/li&gt;
  &lt;li&gt;允许简单的全文搜索以及较复杂的短语搜索&lt;/li&gt;
  &lt;li&gt;支持在匹配文档内容中高亮显示搜索片段&lt;/li&gt;
  &lt;li&gt;支持基于数据创建和管理分析仪表盘&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;索引存储雇员文档&quot;&gt;索引（存储）雇员文档&lt;/h2&gt;
&lt;p&gt;这将会以 雇员文档 的形式存储：一个文档代表一个雇员。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你也许已经注意到 索引 这个词在 Elasticsearch 语境中包含多重意思， 所以有必要做一点儿说明：
索引（名词）：&lt;/p&gt;

  &lt;p&gt;如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。&lt;/p&gt;

  &lt;p&gt;索引（动词）：&lt;/p&gt;

  &lt;p&gt;索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。&lt;/p&gt;

  &lt;p&gt;倒排索引：
关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。&lt;/p&gt;

  &lt;p&gt;默认的，一个文档中的每一个属性都是 被索引 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。我们将在 倒排索引 讨论倒排索引的更多细节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/1&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;first_name&quot; : &quot;John&quot;,
    &quot;last_name&quot; :  &quot;Smith&quot;,
    &quot;age&quot; :        25,
    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;轻量搜索&quot;&gt;轻量搜索&lt;/h2&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search?q=last_name:Smith&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;查询表达式-query-dsl&quot;&gt;查询表达式 Query DSL&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;last_name&quot; : &quot;Smith&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更复杂的搜索&quot;&gt;更复杂的搜索&lt;/h2&gt;
&lt;p&gt;同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;bool&quot;: {
            &quot;must&quot;: {
                &quot;match&quot; : {
                    &quot;last_name&quot; : &quot;smith&quot;
                }
            },
            &quot;filter&quot;: {
                &quot;range&quot; : {
                    &quot;age&quot; : { &quot;gt&quot; : 30 }
                }
            }
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;全文搜索&quot;&gt;全文搜索&lt;/h2&gt;
&lt;p&gt;Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;短语搜索&quot;&gt;短语搜索&lt;/h2&gt;
&lt;p&gt;找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者短语 。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;高亮搜索&quot;&gt;高亮搜索&lt;/h2&gt;
&lt;p&gt;许多应用都倾向于在每个搜索结果中 高亮 部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    },
    &quot;highlight&quot;: {
        &quot;fields&quot; : {
            &quot;about&quot; : {}
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;aggs&quot;: {
    &quot;all_interests&quot;: {
      &quot;terms&quot;: { &quot;field&quot;: &quot;interests&quot; }
    }
  }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分布式特性&quot;&gt;分布式特性&lt;/h2&gt;
&lt;p&gt;Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中&lt;/li&gt;
  &lt;li&gt;按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡&lt;/li&gt;
  &lt;li&gt;复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失&lt;/li&gt;
  &lt;li&gt;将集群中任一节点的请求路由到存有相关数据的节点&lt;/li&gt;
  &lt;li&gt;集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">你知道的，为了搜索…</summary></entry><entry><title type="html">九州</title><link href="http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html" rel="alternate" type="text/html" title="九州" /><published>2018-05-07T00:00:00+08:00</published><updated>2018-05-07T00:00:00+08:00</updated><id>http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents</id><content type="html" xml:base="http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html">&lt;p&gt;九州设定
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;设定&quot;&gt;设定&lt;/h2&gt;

&lt;p&gt;最初，世界只有混沌，无数的基本粒子，漫无边际地飘荡在混沌中，没有方向，没有边界，没有时间。&lt;/p&gt;

&lt;p&gt;粒子间凝聚和排斥的力量使得混沌中产生了运动。当运动的趋势逐渐发展后，混沌被某一个偶然的搅动打破了。这个搅动只是那些粒子偶然出现的有序排列，奇妙的图纹隐现在混沌中，有序的排列组合第一次出现在混沌中。这就是第一个意识。&lt;/p&gt;

&lt;p&gt;意识的特性将可延续的、可积累的认知阶段当做是真实的，那一段时间中意识的活动称为“醒”；将断断续续的、不积累的那一段当做是虚幻的，那一段时间中的意识活动称为“梦”。第一个意识进入了断续的梦境。梦境中的意识不断地加强自己，对抗重新归于混沌的凝聚力量。当这个意识强大到足以辨别自己的时候，它忽然从梦幻里醒来，开始认识所处的世界。这个意识发现周围的世界竟然不是它的梦而仅仅是混沌。有序的梦境与它所存在的混沌的世界存在强烈的反差，使得这个意识产生了创造的愿望。&lt;/p&gt;

&lt;p&gt;在世界初始的那一段时间里，第一个意识不断的加强自己，对抗重新归于混沌的凝聚力量。&lt;/p&gt;

&lt;p&gt;这个意识被称作世界的第一个主神“墟”。而混沌本身则产生了对应的概念上的主神“荒”。荒代表无所不在的强大凝聚力，可是他没有意识。&lt;/p&gt;

&lt;p&gt;墟是精神的主神，荒是物质的主神。&lt;/p&gt;

&lt;p&gt;荒想要重新回复到混沌状态，而墟不允许荒破坏他的创造，于是他奋力撞击在混沌的中心，从而导致整个混沌产生了空前绝后的大爆炸，荒的一部分身体被震碎为尘埃，他的主体却被凝聚力牢牢地抓住，形成了一个被称作大地的球体。而墟在撞击中完全粉碎，他精神的碎片化成无数星辰瞬间飞出了混沌，却被凝聚的力量抓在环绕在球体的周围。星辰的精神也成为第一批有独立意识的次神。&lt;/p&gt;

&lt;p&gt;次神是墟的碎片，他们微弱地回忆起主神墟的意志是阻止世界重新凝聚为混沌。可是荒所具有的强大凝聚力依然在吸引周围的物质碎片。这一力量最终将会导致星辰诸神被吸聚回主神荒，回到混沌状态。&lt;/p&gt;

&lt;p&gt;惊恐的诸神于是在荒的身体上施展一个法术，他们用荒的碎片中的精华物质制造了捆绑束缚荒的封印，布满主神荒的身体，以阻止荒的凝聚，并且不惜把自己的一部分精神加入这些封印图纹，使之具有意识。这就是生命的诞生。&lt;/p&gt;

&lt;p&gt;这些生物中，得到了较多精神力的，逐渐发展成为具有文明的智慧种族。&lt;/p&gt;

&lt;p&gt;诸神明白只有精神的力量才能阻止荒的凝聚，因此他们把这些生物放置在大地的四方，并赋予它们自由意识所具有的一切矛盾特性：对秩序的向往和争战的本能。诸神希望各种冲突力量阻止这些种族走到一起，从而荒的碎片不会彻底融合，也就不会有新的混沌。&lt;/p&gt;

&lt;p&gt;任何精神体都是矛盾的，墟希望通过最终战争实现一个完全由他意识建立的有序世界，而荒则默默的行使力量把世界重新凝聚成一个无序的混沌整体。当今世界只是墟依照无尽梦幻中的体验而创造的模型，墟从当今的世界中汲取创造的经验，希望战胜荒后建立完美的世界。而荒的唯一目的就是毁灭世界归于混沌。&lt;/p&gt;

&lt;p&gt;精神和物质，混乱和秩序，构成了这个世界的终级冲突，并成为一切生物意识中的烙印。&lt;/p&gt;

&lt;h2 id=&quot;地理&quot;&gt;地理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/九州地图.jpg&quot; alt=&quot;九州地图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;九州的已知世界由三块大陆组成，按照上古的传说划分为九个州，这正是九州名称的来源。&lt;/p&gt;

&lt;h3 id=&quot;北陆&quot;&gt;北陆&lt;/h3&gt;

&lt;h4 id=&quot;殇州&quot;&gt;殇州&lt;/h4&gt;
&lt;p&gt;殇州位于北陆西部，二面临海，向北是茫茫雪山冰原的寒冷大陆。东部与翰州以火雷原为界。面积约十万拓。殇州主要分为三大地形带：北部为殇州高原，东起蛮古山脉，西至天池山脉，其中蛮古山脉为北陆最高部分，平均海拔超过1万尺。中部和东部地区地势趋于平缓，长期的剥蚀作用形成了数片广阔而起伏平缓的平原，其间分布有一些小山和丘陵。西南部地区是一条火山带，统称为冰炎地海，分布有数十座较大的火山和更多小型或休眠的火山。更西面在浩瀚洋中分布有火山岛群。
这是一片冰与火的大陆，相应的气候分布也多变。殇州高原气候寒冷，夏季普遍气温低，降水丰沛，无论冬季还是夏季，都是既能下雨，也能下雪。该地区不适于乔木生长，灌木丛和苔原是殇州高原的常见植被。西南部地热资源丰富，可见到木本植物组成的小林，在背风的地方或热泉附近分布着杂草草甸。中东部的平原区气候状况比瀚州平原略复杂，以森林植被为主，针叶林的分布最为广泛，阔叶树的种类较少，森林草原和草原分布在与瀚州的交界处。&lt;/p&gt;

&lt;h4 id=&quot;瀚州&quot;&gt;瀚州&lt;/h4&gt;
&lt;p&gt;瀚州位于北陆中部，东连宁州，西接殇州，总面积约十五万拓。西南是涣海，下端指向滁潦海。西部受到殇州高原地形带的影响，平均海拔较高。中部地区地势平坦，一马平川。东部由极宽的天拓大江与中州隔开。西端由霍零江与云州隔开。 瀚州大部分地区降水量不足，森林不能自然生长，以草原为主，自然植被主要是丛生禾草，并混生有多种双子叶杂草。东部彤云山地区则由森林草原逐渐向混交林区过渡。溟朦海位于翰州中部草原，是北陆最大的湖泊，周围形成形成大片的绿州沃野。&lt;/p&gt;

&lt;h4 id=&quot;宁州&quot;&gt;宁州&lt;/h4&gt;
&lt;p&gt;宁州位于北陆最东部，三面临海，面积约十一万拓，其东南部为丘陵地带，分布森林和森林草原，乌鬼山横越其北，三昧河自此向南入海口时，变成了三条纵横交错的宽阔河道，因为土质和藻类的不同，分别呈青绿，淡紫和绛红三种颜色。宁州西部多为荒漠戈壁，众多破碎的丘陵一路连向虎皮山脉。极西端与瀚州间隔勾弋山，勾弋山高万仞，因为山峰终年积雪，云开雾散之际银光闪闪，又被称为”月亮山脉”，其主峰为北陆最高山。宁州北部多为厚厚的冰川层覆盖，这块巨大冰原的面积几乎相当于四分之一的宁州，主要植被是在短暂的夏季中长满的苔藓和草本植物。&lt;/p&gt;

&lt;h3 id=&quot;东陆&quot;&gt;东陆&lt;/h3&gt;
&lt;h4 id=&quot;澜州&quot;&gt;澜州&lt;/h4&gt;
&lt;p&gt;澜州位于东陆东块，东部临海，西接中州，南部与越州为邻。面积约十五万拓。整个澜州形势如弓，销金河如弦横跨南北，东陆最高峰的擎梁山就架在弓脊上。澜州平均海拔超过3000尺，是东陆平均海拔最高的地区，地堑性的中央低地把澜州分割为东北和西南两部。东北的夜北高原是一个地垒性地块，西南与越州交界处由于降水较多，是大片的沼泽地和森林。 整个夜北高原土地凉薄，兼之气候不利，一年中冬季长达5个月，除了寒地的针叶林生长颇速，农作物生长却非常不利，重要的粮食产区仅在西南小部分地域。沼泽地和森林带人迹稀少，树木林冠稠密，层次很多，且多藤本和附生植物。&lt;/p&gt;

&lt;h4 id=&quot;中州&quot;&gt;中州&lt;/h4&gt;
&lt;p&gt;中州位于东陆的北块，南接宛州，东靠澜州。面积约十五万拓，是东陆第一大州。中州地形以山脉和平原为主，从澜州夜北高原延伸下东西走向的两条隆起带和二条沉降带，隆起带主要为山地地形，沉降带则形成为盆地和平原。 中州的风向、降水均随季节而有明显的更替，自然植被以森林为主，既有冷湿性森林、森林草原景观，又有半湿润半干旱夏绿林、森林草原景观，混有落叶阔叶林。&lt;/p&gt;

&lt;h4 id=&quot;宛州&quot;&gt;宛州&lt;/h4&gt;
&lt;p&gt;宛州位于东陆西块，北与中州交界，东与越州相邻。面积约十二万拓。宛州地形受到建水与西江以及诸多小河流的切割，大部分呈丘陵状，只有与中州交接的平原才是宛州的平坦部分。宛州东部受到雷眼山脉和北邙山脉影响，地势较复杂，雁返湖是宛州大部分河流的发源地。 宛州气候温和的，冬不太冷，夏不太热，降水适中，大多数地区没有干旱的感觉。这种气候条件适宜于木本植物的生长，阔叶林是本区的地带性植被。&lt;/p&gt;

&lt;h4 id=&quot;越州&quot;&gt;越州&lt;/h4&gt;
&lt;p&gt;越州位于东陆南块，面积约十二万拓，在东陆四州中列于第三。越州中部和西部地区以丘陵和低山为主，雷眼、北邙山脉诸多延伸山脉呈绵延不断的岭脊，主要是块状山，峰峦耸立，山坡陡峭，岩石裸露，地形十分崎岖，山岭间错纵地分布着面积不大的山谷和盆地，盆地中水源丰富，东部和北部沿岸为海岸平原，沿海沙洲、潟湖较多，东南部还有珊瑚礁海岸。 越州的基本植被是硬叶常绿群落，不限于分布在沿海和平原地区，并沿河谷深入到山地内部，由于越州是人口最稀少的地区，全境森林覆盖率达到60％至70％。&lt;/p&gt;

&lt;h3 id=&quot;西陆&quot;&gt;西陆&lt;/h3&gt;
&lt;h4 id=&quot;云州&quot;&gt;云州&lt;/h4&gt;
&lt;p&gt;面积均约十二万拓，与雷州以中部被称为沉沙海的海湾为界。由于云州西部为高耸的赤华山脉，东部有丘陵群，地势较高，天高云远，所以中部有连片沙漠，与山谷交错着。&lt;/p&gt;

&lt;h3 id=&quot;雷州&quot;&gt;雷州&lt;/h3&gt;
&lt;p&gt;面积约十三万拓。与云州截然不同，气候调和，植物茂盛多样，两边临海，气候多雨潮湿，森林茂密。&lt;/p&gt;

&lt;h2 id=&quot;种族&quot;&gt;种族&lt;/h2&gt;

&lt;h3 id=&quot;人族&quot;&gt;人族&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;人是最平均也最复杂的种族，他们没有关夸父的高大，河络的技术，羽族的轻灵，鲛人的善水，魅的魔力。但他们有最庞大的人口和最完善的制度文明。人族有北陆，东陆，西陆三大文明带。北陆人为游牧文明，东陆人为农业文明，西陆的城邦文明则因为瘟疫而淹没在沙漠密林之后，成为探险发现的天堂。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;羽族&quot;&gt;羽族&lt;/h3&gt;
&lt;h3 id=&quot;夸父&quot;&gt;夸父&lt;/h3&gt;
&lt;h3 id=&quot;河络&quot;&gt;河络&lt;/h3&gt;
&lt;h3 id=&quot;鲛人&quot;&gt;鲛人&lt;/h3&gt;
&lt;h3 id=&quot;魅族&quot;&gt;魅族&lt;/h3&gt;</content><author><name>Tesla Lee</name></author><summary type="html">九州设定</summary></entry><entry><title type="html">Query DSL of Elasticsearch</title><link href="http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html" rel="alternate" type="text/html" title="Query DSL of Elasticsearch" /><published>2018-05-04T00:00:00+08:00</published><updated>2018-05-04T00:00:00+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html">&lt;p&gt;Elasticsearch 查询 DSL 基础知识&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;query-dsl&quot;&gt;Query DSL&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf query clauses（子查询）：在一个特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt; 查询特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 查询。&lt;/li&gt;
  &lt;li&gt;Compound query clauses（组合查询）：将子查询或组合查询再组合起来，例如，使用逻辑（&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;dis_max&lt;/code&gt;)，或者改变查询的行为（&lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Query clauses behave differently depending on whether they are used in query context or filter context.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;query-and-filter-context&quot;&gt;Query and filter context&lt;/h2&gt;

&lt;p&gt;The behaviour of a query clause depends on whether it is used in query context or in filter context:&lt;/p&gt;

&lt;h3 id=&quot;query-context&quot;&gt;Query context&lt;/h3&gt;
&lt;p&gt;A query clause used in query context answers the question “&lt;strong&gt;How well does this document match this query clause?&lt;/strong&gt;”.The query clause also calculates a _score representing how well the document matches, relative to other documents.&lt;/p&gt;

&lt;h3 id=&quot;filter-context&quot;&gt;Filter Context&lt;/h3&gt;
&lt;p&gt;In filter context, a query clause answers the question “&lt;strong&gt;Does this document match this query clause?&lt;/strong&gt;”&lt;/p&gt;

&lt;p&gt;Frequently used filters will be cached automatically by Elasticsearch, to speed up performance.&lt;/p&gt;

&lt;p&gt;Filter context is in effect whenever a query clause is passed to a filter parameter, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;must_not&lt;/code&gt; parameters in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; query, the filter parameter in the &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt; query, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; aggregation.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_search&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;query&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;must&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Search&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Elasticsearch&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;filter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;term&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;published&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;range&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;publish_date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gte&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-01-01&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; 指 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 和两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt; 使用，来评价每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt; 的评分&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 语句是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt; 中使用，他们用来筛选 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题：&lt;code class=&quot;highlighter-rouge&quot;&gt;Filter context&lt;/code&gt; 是在计算 score 前执行还是在计算 score 后执行？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;match-all-query&quot;&gt;Match all query&lt;/h2&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match_all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;匹配所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，并且给它们一个默认分数 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;full-text-queries&quot;&gt;Full text queries&lt;/h2&gt;
&lt;p&gt;The high-level full text queries are usually used for running full text queries on full text fields like the body of an email.They understand how the field being queried is analyzed and will apply each field’s analyzer (or search_analyzer) to the query string before executing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; query: 单个基础全文搜索，包括模糊、短语或近似查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi_match&lt;/code&gt; query: 多个字段的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;common_terms&lt;/code&gt; query: 更特殊的查询，用于处理一些不常用的词&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query_string&lt;/code&gt; query: Supports the compact Lucene query string syntax, allowing you to specify AND&lt;/td&gt;
          &lt;td&gt;OR&lt;/td&gt;
          &lt;td&gt;NOT conditions and multi-field search within a single query string. For expert users only.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple_query_string&lt;/code&gt;: A simpler, more robust version of the query_string syntax suitable for exposing directly to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;match-query&quot;&gt;Match Query&lt;/h3&gt;

&lt;h4 id=&quot;boolean&quot;&gt;boolean&lt;/h4&gt;

&lt;p&gt;默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询是 &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 查询 DSL 基础知识</summary></entry><entry><title type="html">Basic Concept of Elasticsearch</title><link href="http://www.teslalee.com/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html" rel="alternate" type="text/html" title="Basic Concept of Elasticsearch" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/03/basic-concept-of-elasticsearch</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html">&lt;p&gt;Elasticsearch 中的几个基本概念&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Near Realtime(NRT)&lt;/strong&gt;：接近实时，意味着，当你将内容存储到 Elasticsearch 后，大概最多一秒钟后就可以搜索了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：集群是一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;，并且在此基础上提供索引与搜索等功能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 就是一个集群中的单台服务器，它存储数据，参与整个集群的数据索引和搜索功能。一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 在启动时会加入到指定的集群中去。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是一组有特定属性的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Documents&lt;/code&gt;。比如，你可以有个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放客户数据的，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放产品目录。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：对于一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;，你可以指定一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，你自己可以赋予它任何意义。一般来说，比如多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 有相同的几个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;，那么它们可以认为是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 是能够被索引的基本单元。比如，一个客户有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shards &amp;amp; Replicas&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 存储的数据可能会非常庞大， 以至于单台机器并没有办法存放这些数据。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt;：为了解决这个问题，所以引入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 来将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 分成多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt;，每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 可以认为是一个独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;。我们在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 时，可以指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的数量。&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 提供了以下两个主要功能：
        &lt;ul&gt;
          &lt;li&gt;可以将你的内容平行分割扩展&lt;/li&gt;
          &lt;li&gt;可以提供分布式并行操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的管理完全由 Elasticsearch 接手。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Replica&lt;/strong&gt;：任何系统都需要有失败恢复机制。而 &lt;strong&gt;Replica&lt;/strong&gt; 或者 &lt;strong&gt;Replica Shard&lt;/strong&gt; 就提供这样的功能，它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的备份。它提供两个主要功能。
        &lt;ul&gt;
          &lt;li&gt;当一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard/Node&lt;/code&gt; 出错时，依然可以保持功能完整。所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;Replica&lt;/code&gt; 与 原 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 永远不会存放在同一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 上面。&lt;/li&gt;
          &lt;li&gt;它可以帮助扩展你的搜索数据量，因为所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 都会被搜索到。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 中的几个基本概念</summary></entry><entry><title type="html">Chapter 2 - Lexical Analysis</title><link href="http://www.teslalee.com/compiler/2018/04/26/lexical-analysis.html" rel="alternate" type="text/html" title="Chapter 2 - Lexical Analysis" /><published>2018-04-26T00:00:00+08:00</published><updated>2018-04-26T00:00:00+08:00</updated><id>http://www.teslalee.com/compiler/2018/04/26/lexical-analysis</id><content type="html" xml:base="http://www.teslalee.com/compiler/2018/04/26/lexical-analysis.html">&lt;p&gt;『Modern Compiler Implementation in C』词法分析部分笔记和总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;lex-i-cal&lt;/strong&gt; : of or relating to words or the vocabulary of a language as distinguished from its grammar and construction&lt;/p&gt;

  &lt;p&gt;— Webster’s Dictionary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要将程序从一种语言翻译到另一种语言，编译器要先将程序处理成&lt;strong&gt;片段&lt;/strong&gt;，并理解其&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;意义&lt;/strong&gt;，然后将片段重新再组合。编译器前端负责&lt;strong&gt;分析&lt;/strong&gt;，而后端负责&lt;strong&gt;整合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;分析工作主要:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析（Lexical analysis）：将输入识别成词素，既（Lexical Token）&lt;/li&gt;
  &lt;li&gt;语法分析（Syntax analysis）：分析程序的结构&lt;/li&gt;
  &lt;li&gt;语义分析（Semantic analysis）：计算出程序的意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;词法分析器输入字符流，输出词，关键字，符号等。&lt;/p&gt;

&lt;h2 id=&quot;lexical-tokens词素&quot;&gt;LEXICAL TOKENS（词素）&lt;/h2&gt;
&lt;p&gt;Lexical token 是一个字符序列，它是一门语言的最小语法元素。一门编程语言的 token 类型，是一个有限集合。&lt;/p&gt;

&lt;h3 id=&quot;例如&quot;&gt;例如：&lt;/h3&gt;

&lt;p&gt;Token 类型 例子&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; foo n14, last&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NUM&lt;/code&gt; 74 0 00 082&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;REAL&lt;/code&gt; 66.1 .5 10. 1e66 5.5e-10&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; if&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; ,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NOTEQ&lt;/code&gt; !=&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; (&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 if，void，这样的符号，我们称之为&lt;strong&gt;保留字&lt;/strong&gt;，在大部分语言里，保留字不能作为 ID 来使用。除了上面这些 Token 以外，字符流中还有非 token 内容。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注释  /* try again */&lt;/li&gt;
  &lt;li&gt;预处理 #include &lt;stdio.h&gt;&lt;/stdio.h&gt;&lt;/li&gt;
  &lt;li&gt;预处理 #define NUMS 5 , 6&lt;/li&gt;
  &lt;li&gt;宏 NUMS&lt;/li&gt;
  &lt;li&gt;空格，换行，缩进等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弱语言需要有一个宏预处理器，宏预处理去先操作输入流，进行预处理，生成新的字符流输出给词法分析器。当然，也可以直接将宏预处理器集成到词法分析器中去。&lt;/p&gt;

&lt;p&gt;比如有这样一段代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* find a zero */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;match0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;词法分析器在输入这段代码后，会输出：
&lt;code class=&quot;highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(match0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CHAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;BAND&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(strncmp)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;NUM(3)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RETURN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;REAL(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SEMI&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;EOF&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从上面的输出我们可以看到，每一个输出的 Token 都有类型。其中，像 &lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING&lt;/code&gt; 等会带有值来提供额外的信息。&lt;/p&gt;

&lt;p&gt;那么，接下来的问题是，我们用什么来描述 Token 的规则？用什么语言来实现词法分析器？我们完全可以使用自然语言来直接描述规则，比如下面这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;标识符（ID）&lt;/code&gt;是由字母和数字组成的字符序列，首个字符必须是字母开头。同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 下划线也认为是字母。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时,我们也可以使用任意合适的语言去实现词法分析器。不过，在这里，我们会使用&lt;strong&gt;正则表达式&lt;/strong&gt;来描述词法规则，用&lt;strong&gt;确定性有限自动机&lt;/strong&gt;来实现，同时，还会使用&lt;strong&gt;数学语言&lt;/strong&gt;来将这两者联系起来。&lt;/p&gt;

&lt;h2 id=&quot;regular-expression正则表达式&quot;&gt;REGULAR EXPRESSION（正则表达式）&lt;/h2&gt;
&lt;p&gt;一门语言，是一个字符串的集合；字符串是符号的有限序列；符号来自一个优先符号集合。我们这样描述一门语言时，并没有赋予字符串以任何意义，我们只是去区分字符串是否属于这门语言。为了能够仅仅使用有限的规则来描述一门语言，我们使用&lt;strong&gt;正则表达式&lt;/strong&gt;来标记这些规则。每一条&lt;strong&gt;正则表达式&lt;/strong&gt;表示一组字符串。&lt;/p&gt;

&lt;p&gt;下面是正则表达式的基本规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Symbol（符号）&lt;/strong&gt;：对于每一个符号 &lt;strong&gt;a&lt;/strong&gt; ，直接表示字符串 &lt;strong&gt;a&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Alternation（选择）&lt;/strong&gt;：对于 $M \mid N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Concatenation（连续，连接）&lt;/strong&gt;：$M \ast N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Epsilon（空）&lt;/strong&gt;：$\epsilon$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Repetition（重复）&lt;/strong&gt;：重复一次，重复多次，至少重复一次&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kleene closure: Given a regular expression M, its Kleene closure is $M^*$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用以上这些基本规则，我们就可以来表示由 ASCII 字符组成的变成语言了。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(0 \mid 1)^\ast \ast 0$ 表示任意能被 2 整除的二进制数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$ : 普通字符&lt;/li&gt;
  &lt;li&gt;$\epsilon$ : 空字符串&lt;/li&gt;
  &lt;li&gt;$M \mid N$ : 选择 M 或 N&lt;/li&gt;
  &lt;li&gt;$M \bullet N$ (MN) : 连接&lt;/li&gt;
  &lt;li&gt;$M^\ast$ : 重复出现零次或多次&lt;/li&gt;
  &lt;li&gt;$M^+$ : 重复出现一次或多次&lt;/li&gt;
  &lt;li&gt;$M?$ : 出现一次或者不出现&lt;/li&gt;
  &lt;li&gt;$[a-zA-Z]$: 再大小写字母中选择&lt;/li&gt;
  &lt;li&gt;$\bullet$ : 表示任意字符&lt;/li&gt;
  &lt;li&gt;“$a.+^\ast$” : 精确匹配完成字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入正则表达式后，我们就可以来描述词法规则了&lt;/p&gt;

&lt;p&gt;假如有下面这样的 C 代码片段：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* do nothing */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有关键字 &lt;strong&gt;if&lt;/strong&gt;，标识符 &lt;strong&gt;ID&lt;/strong&gt;，数字 &lt;strong&gt;NUM&lt;/strong&gt;，以及实数 &lt;strong&gt;REAL&lt;/strong&gt;，还定义了注释 『–』开头的单行注释。第五行是注释，意味着词法分析器会跳过它们继续执行，同时，词法分析器应该是功能完整的。它应该能够处理所有的符号，包括错误的。&lt;/p&gt;

&lt;p&gt;写到这里，我们很快会注意到一个问题：&lt;strong&gt;IF&lt;/strong&gt; 和 &lt;strong&gt;ID&lt;/strong&gt; 这两个规则是有交集的。在没有假如更多规则的情况下，我们如何去识别 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 到底是 &lt;strong&gt;ID token&lt;/strong&gt; 还是 &lt;strong&gt;IF token&lt;/strong&gt;？再比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是先匹配 &lt;strong&gt;IF&lt;/strong&gt; 规则还是先匹配 &lt;strong&gt;ID&lt;/strong&gt; 规则？&lt;/p&gt;

&lt;p&gt;下面引入两种常用的去歧义规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Longest match&lt;/strong&gt;：也就是最长匹配原则，规则所能匹配的最长子串作为下一个输出的 token。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rule priority&lt;/strong&gt;：规则优先级原则，对于一个最长子串，第一个能够匹配的规则所表示 token 作为输。这也就意味着，匹配的顺序是有意义且重要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入了这两个规则之后，我们就可以确定 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 是 &lt;strong&gt;IF&lt;/strong&gt; token 了，因为它最新匹配了 &lt;strong&gt;IF&lt;/strong&gt;，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是 &lt;strong&gt;ID&lt;/strong&gt; token.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;好了，到这里可以先简单的做一下总结。一门语言，有其最基本的语法元素，这里是 Lexical token。我们需要描述每一种 token 的规则，当然可以使用自然语言，但要让 Lexer 理解，必须要使用一种能实现成程序的方式。
于是我们引入了 Regular Expression 来描述词法规则。同时付加了两条消除歧义的规则，&lt;strong&gt;最长匹配&lt;/strong&gt;和&lt;strong&gt;匹配优先级&lt;/strong&gt;
那么，到这里我有一个疑问，&lt;strong&gt;是不是使用 Regular Expression 就足够实现词法分析了？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finite-automata&quot;&gt;FINITE AUTOMATA&lt;/h2&gt;

&lt;p&gt;前面有个问题：有了&lt;strong&gt;正则表达式&lt;/strong&gt;，是不是就可以直接使用&lt;strong&gt;正则&lt;/strong&gt;来实现词法匹配了？毕竟大多数的语言都有&lt;strong&gt;正则&lt;/strong&gt;的实现。对的，用正则来实现词法分析器是完全没有问题的。&lt;/p&gt;

&lt;p&gt;这里我正好在网上搜到了 Rob Pike 一篇文章 &lt;a href=&quot;https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html&quot;&gt;Regular expression in lexing and parsing&lt;/a&gt;。摘取他的观点放在这里。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are hard to write, hard to write well, and can be expensive relative to other technologies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A regular expression library is a big thing. Using one to parse identifiers is like using a Mack truck to go to the store for milk. And when we want to adjust our lexer to admit other character types, such as Unicode identifiers, and handle normalization, and so on, the hand-written loop can cope easily but the regexp approach will break down.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Using regular expressions to explore the parse state to find the way forward is expensive, overkill, and error-prone.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are, in my experience, widely misunderstood and abused.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里我不深入这个问题，后面我会尝试实现一个基于&lt;strong&gt;正则表达式&lt;/strong&gt;的词法分析器。&lt;/p&gt;

&lt;h3 id=&quot;什么是有限自动机&quot;&gt;什么是有限自动机？&lt;/h3&gt;

&lt;p&gt;我们这里直接使用有限自动机来实现词法分析的功能。有限自动机由 &lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边&lt;/strong&gt;，&lt;strong&gt;符号&lt;/strong&gt; 组成，状态有 &lt;strong&gt;终结状态&lt;/strong&gt; 和 &lt;strong&gt;开始状态&lt;/strong&gt;。有限自动机是一种状态机，它通过状态转化来实现接受或者拒绝特定字符串的功能。这里直接摘取维基百科对于状态机的定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types - deterministic finite state machines and non-deterministic finite state machines.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The finite state machine has less computational power than some other models of computation such as the Turing machine.[2] The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM’s memory is limited by the number of states it has. FSMs are studied in the more general field of automata theory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，现在引入了有限自动机这个概念。
有限自动机可以很方便的是现成程序。
有限自动机由：&lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边（从一个状态到另一个状态）&lt;/strong&gt;，&lt;strong&gt;边上的符号&lt;/strong&gt;，&lt;strong&gt;开始状态&lt;/strong&gt; 和 &lt;strong&gt;终结状态&lt;/strong&gt; 组成。&lt;/p&gt;

&lt;p&gt;有限自动机分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA 确定性有限自动机：从一个状态接收，只有唯一确定的边指向另一个状态。&lt;/li&gt;
  &lt;li&gt;NFA 非确定性有限自动机：从一个状态接收，有多个不同的状态可以到达。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我们可以给上面的词法规则画出如下的几个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_1.png&quot; alt=&quot;Fig 2.3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们也可以写成一个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_2.png&quot; alt=&quot;Fig 2.4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;EXERCISES&lt;/h2&gt;

&lt;p&gt;2.1 Write regular expressions for each of the following.&lt;/p&gt;

&lt;p&gt;a. String over the alphabet $ \{ a,b,c \} $ where the first $a$ precedes the first $b$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：因为必须第一个 $a$ 出现在第一个 $b$ 后面，所以实际上只有两种情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;第一个 $a$ 前面只有 $c$&lt;/li&gt;
    &lt;li&gt;没有出现 $a$&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ c^\ast a[abc]^\ast \mid [bc]^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;b. String over the alphabet {a,b,c} with an even number of a’s.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：需要 $a$ 的个数是偶数个
同样也分解情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;两个 $a$ 连续出现&lt;/li&gt;
    &lt;li&gt;两个 $a$ 没有连续出现，中间有其他字符&lt;/li&gt;
    &lt;li&gt;可以为空
将上面的三种情况组合起来，得到答案&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ (a([bc]^\ast aa[bc]^\ast )^\ast a)^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;c. Binary numbers that are multiples of four.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$0\mid1^\ast00$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;d. Binary numbers that are greater than 101001.&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;e. String over the alphabet {a,b,c} that don’t contain the contiguous string baa.&lt;/p&gt;

&lt;p&gt;f. The language of nonnegative integer constants in C, where numbers beginning with 0 are octal constants and other numbers are decimal constants.&lt;/p&gt;

&lt;p&gt;g. Binary numbers n such that there exists an integer solution of $a^n + b^n = c^n$.&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">『Modern Compiler Implementation in C』词法分析部分笔记和总结。</summary></entry><entry><title type="html">Notes on Machine Learning on Coursera</title><link href="http://www.teslalee.com/2018/04/25/notes-of-machine-larning-on-coursera.html" rel="alternate" type="text/html" title="Notes on Machine Learning on Coursera" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://www.teslalee.com/2018/04/25/notes-of-machine-larning-on-coursera</id><content type="html" xml:base="http://www.teslalee.com/2018/04/25/notes-of-machine-larning-on-coursera.html">&lt;p&gt;I always want to learn Machine Learning and finally I got time.&lt;/p&gt;

&lt;p&gt;I first started with the open class CS 229 Machine Learning from Stanford by Andrew Ng. But I failed after 2 classes, because Andrew Ng skipped some math detail that I forget the knowledge of calculus and linear algebra.&lt;/p&gt;

&lt;p&gt;Then I find the Machine Learning by Andrew Ng on &lt;a href=&quot;http://www.coursera.com/&quot;&gt;Coursera&lt;/a&gt; is great.&lt;/p&gt;

&lt;p&gt;The learning curve of class is more gentle, and all math details are covered in the course.&lt;/p&gt;

&lt;p&gt;So if you want to learning machine learning, I highly recommend you try this course. All you want to know is the basic knowledge of calculus and linear algebra, which also covered in the course.&lt;/p&gt;

&lt;p&gt;Yeah!&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">I always want to learn Machine Learning and finally I got time.</summary></entry><entry><title type="html">《头号玩家》</title><link href="http://www.teslalee.com/2018/04/02/ready-player-one.html" rel="alternate" type="text/html" title="《头号玩家》" /><published>2018-04-02T00:00:00+08:00</published><updated>2018-04-02T00:00:00+08:00</updated><id>http://www.teslalee.com/2018/04/02/ready-player-one</id><content type="html" xml:base="http://www.teslalee.com/2018/04/02/ready-player-one.html">&lt;p&gt;看完《头号玩家》后，有一个问题一直在脑海里盘旋：
『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』&lt;/p&gt;

&lt;p&gt;到刚才，在微博上看到梅原大吾用隆完全格挡春丽的大招时，我才忽然明白。&lt;/p&gt;

&lt;p&gt;《头号玩家》带给我的感觉：&lt;/p&gt;

&lt;p&gt;它瞬间把我拉回了童年，那个在一群人在家里，围着游戏机一起通关的场景。&lt;/p&gt;

&lt;p&gt;之所以喜悦是因为那种久违的感觉，而忧伤是，你知道永远也不会再回去了。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">看完《头号玩家》后，有一个问题一直在脑海里盘旋： 『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』</summary></entry></feed>