<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-07T15:41:14+08:00</updated><id>http://localhost:4000/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">九州</title><link href="http://localhost:4000/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html" rel="alternate" type="text/html" title="九州" /><published>2018-05-07T00:00:00+08:00</published><updated>2018-05-07T00:00:00+08:00</updated><id>http://localhost:4000/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents</id><content type="html" xml:base="http://localhost:4000/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html">&lt;p&gt;九州设定
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;设定&quot;&gt;设定&lt;/h2&gt;
&lt;p&gt;最初的远古，世界只有混沌，无数最基本的粒子漫无边际的飘荡在混沌的海洋中，没有方向，没有边界，也没有时间。粒子间凝聚和排斥的力量使得混沌中产生了运动。当运动的趋势逐渐发展后，混沌被某一个偶然的搅动打破了。这个搅动只是那些粒子偶然出现的有序排列，奇妙的图纹隐现在混沌中，有序的排列组合第一次出现在混沌中。这就是第一个意识。&lt;/p&gt;

&lt;p&gt;意识的特性将可延续的、可积累的认知阶段当做是真实的，那一段时间中意识的活动称为“醒”；将断断续续的、不积累的那一段当做是虚幻的，那一段时间中的意识活动称为“梦”。第一个意识进入了断续的梦境。梦境中的意识不断地加强自己，对抗重新归于混沌的凝聚力量。当这个意识强大到足以辨别自己的时候，它忽然从梦幻里醒来，开始认识所处的世界。这个意识发现周围的世界竟然不是它的梦而仅仅是混沌。有序的梦境与它所存在的混沌的世界存在强烈的反差，使得这个意识产生了创造的愿望。&lt;/p&gt;

&lt;p&gt;在世界初始的那一段时间里，第一个意识不断的加强自己，对抗重新归于混沌的凝聚力量。&lt;/p&gt;

&lt;p&gt;这个意识被称作世界的第一个主神“墟”。而混沌本身则产生了对应的概念上的主神“荒”。荒代表无所不在的强大凝聚力，可是他没有意识。&lt;/p&gt;

&lt;p&gt;墟是精神的主神，荒是物质的主神。&lt;/p&gt;

&lt;p&gt;荒想要重新回复到混沌状态，而墟不允许荒破坏他的创造，于是他奋力撞击在混沌的中心，从而导致整个混沌产生了空前绝后的大爆炸，荒的一部分身体被震碎为尘埃，他的主体却被凝聚力牢牢地抓住，形成了一个被称作大地的球体。而墟在撞击中完全粉碎，他精神的碎片化成无数星辰瞬间飞出了混沌，却被凝聚的力量抓在环绕在球体的周围。星辰的精神也成为第一批有独立意识的次神。&lt;/p&gt;

&lt;p&gt;次神是墟的碎片，他们微弱地回忆起主神墟的意志是阻止世界重新凝聚为混沌。可是荒所具有的强大凝聚力依然在吸引周围的物质碎片。这一力量最终将会导致星辰诸神被吸聚回主神荒，回到混沌状态。&lt;/p&gt;

&lt;p&gt;惊恐的诸神于是在荒的身体上施展一个法术，他们用荒的碎片中的精华物质制造了捆绑束缚荒的封印，布满主神荒的身体，以阻止荒的凝聚，并且不惜把自己的一部分精神加入这些封印图纹，使之具有意识。这就是生命的诞生。&lt;/p&gt;

&lt;p&gt;这些生物中，得到了较多精神力的，逐渐发展成为具有文明的智慧种族。&lt;/p&gt;

&lt;p&gt;诸神明白只有精神的力量才能阻止荒的凝聚，因此他们把这些生物放置在大地的四方，并赋予它们自由意识所具有的一切矛盾特性：对秩序的向往和争战的本能。诸神希望各种冲突力量阻止这些种族走到一起，从而荒的碎片不会彻底融合，也就不会有新的混沌。&lt;/p&gt;

&lt;p&gt;任何精神体都是矛盾的，墟希望通过最终战争实现一个完全由他意识建立的有序世界，而荒则默默的行使力量把世界重新凝聚成一个无序的混沌整体。当今世界只是墟依照无尽梦幻中的体验而创造的模型，墟从当今的世界中汲取创造的经验，希望战胜荒后建立完美的世界。而荒的唯一目的就是毁灭世界归于混沌。&lt;/p&gt;

&lt;p&gt;精神和物质，混乱和秩序，构成了这个世界的终级冲突，并成为一切生物意识中的烙印。&lt;/p&gt;

&lt;h2 id=&quot;地理&quot;&gt;地理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/九州地图.jpg&quot; alt=&quot;九州地图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;九州的已知世界由三块大陆组成，按照上古的传说划分为九个州，这正是九州名称的来源。&lt;/p&gt;

&lt;h3 id=&quot;北陆&quot;&gt;北陆&lt;/h3&gt;

&lt;h4 id=&quot;殇州&quot;&gt;殇州&lt;/h4&gt;
&lt;p&gt;殇州位于北陆西部，二面临海，向北是茫茫雪山冰原的寒冷大陆。东部与翰州以火雷原为界。面积约十万拓。殇州主要分为三大地形带：北部为殇州高原，东起蛮古山脉，西至天池山脉，其中蛮古山脉为北陆最高部分，平均海拔超过1万尺。中部和东部地区地势趋于平缓，长期的剥蚀作用形成了数片广阔而起伏平缓的平原，其间分布有一些小山和丘陵。西南部地区是一条火山带，统称为冰炎地海，分布有数十座较大的火山和更多小型或休眠的火山。更西面在浩瀚洋中分布有火山岛群。
这是一片冰与火的大陆，相应的气候分布也多变。殇州高原气候寒冷，夏季普遍气温低，降水丰沛，无论冬季还是夏季，都是既能下雨，也能下雪。该地区不适于乔木生长，灌木丛和苔原是殇州高原的常见植被。西南部地热资源丰富，可见到木本植物组成的小林，在背风的地方或热泉附近分布着杂草草甸。中东部的平原区气候状况比瀚州平原略复杂，以森林植被为主，针叶林的分布最为广泛，阔叶树的种类较少，森林草原和草原分布在与瀚州的交界处。&lt;/p&gt;

&lt;h4 id=&quot;瀚州&quot;&gt;瀚州&lt;/h4&gt;
&lt;p&gt;瀚州位于北陆中部，东连宁州，西接殇州，总面积约十五万拓。西南是涣海，下端指向滁潦海。西部受到殇州高原地形带的影响，平均海拔较高。中部地区地势平坦，一马平川。东部由极宽的天拓大江与中州隔开。西端由霍零江与云州隔开。 瀚州大部分地区降水量不足，森林不能自然生长，以草原为主，自然植被主要是丛生禾草，并混生有多种双子叶杂草。东部彤云山地区则由森林草原逐渐向混交林区过渡。溟朦海位于翰州中部草原，是北陆最大的湖泊，周围形成形成大片的绿州沃野。&lt;/p&gt;

&lt;h4 id=&quot;宁州&quot;&gt;宁州&lt;/h4&gt;
&lt;p&gt;宁州位于北陆最东部，三面临海，面积约十一万拓，其东南部为丘陵地带，分布森林和森林草原，乌鬼山横越其北，三昧河自此向南入海口时，变成了三条纵横交错的宽阔河道，因为土质和藻类的不同，分别呈青绿，淡紫和绛红三种颜色。宁州西部多为荒漠戈壁，众多破碎的丘陵一路连向虎皮山脉。极西端与瀚州间隔勾弋山，勾弋山高万仞，因为山峰终年积雪，云开雾散之际银光闪闪，又被称为”月亮山脉”，其主峰为北陆最高山。宁州北部多为厚厚的冰川层覆盖，这块巨大冰原的面积几乎相当于四分之一的宁州，主要植被是在短暂的夏季中长满的苔藓和草本植物。&lt;/p&gt;

&lt;h3 id=&quot;东陆&quot;&gt;东陆&lt;/h3&gt;
&lt;h4 id=&quot;澜州&quot;&gt;澜州&lt;/h4&gt;
&lt;p&gt;澜州位于东陆东块，东部临海，西接中州，南部与越州为邻。面积约十五万拓。整个澜州形势如弓，销金河如弦横跨南北，东陆最高峰的擎梁山就架在弓脊上。澜州平均海拔超过3000尺，是东陆平均海拔最高的地区，地堑性的中央低地把澜州分割为东北和西南两部。东北的夜北高原是一个地垒性地块，西南与越州交界处由于降水较多，是大片的沼泽地和森林。 整个夜北高原土地凉薄，兼之气候不利，一年中冬季长达5个月，除了寒地的针叶林生长颇速，农作物生长却非常不利，重要的粮食产区仅在西南小部分地域。沼泽地和森林带人迹稀少，树木林冠稠密，层次很多，且多藤本和附生植物。&lt;/p&gt;

&lt;h4 id=&quot;中州&quot;&gt;中州&lt;/h4&gt;
&lt;p&gt;中州位于东陆的北块，南接宛州，东靠澜州。面积约十五万拓，是东陆第一大州。中州地形以山脉和平原为主，从澜州夜北高原延伸下东西走向的两条隆起带和二条沉降带，隆起带主要为山地地形，沉降带则形成为盆地和平原。 中州的风向、降水均随季节而有明显的更替，自然植被以森林为主，既有冷湿性森林、森林草原景观，又有半湿润半干旱夏绿林、森林草原景观，混有落叶阔叶林。&lt;/p&gt;

&lt;h4 id=&quot;宛州&quot;&gt;宛州&lt;/h4&gt;
&lt;p&gt;宛州位于东陆西块，北与中州交界，东与越州相邻。面积约十二万拓。宛州地形受到建水与西江以及诸多小河流的切割，大部分呈丘陵状，只有与中州交接的平原才是宛州的平坦部分。宛州东部受到雷眼山脉和北邙山脉影响，地势较复杂，雁返湖是宛州大部分河流的发源地。 宛州气候温和的，冬不太冷，夏不太热，降水适中，大多数地区没有干旱的感觉。这种气候条件适宜于木本植物的生长，阔叶林是本区的地带性植被。&lt;/p&gt;

&lt;h4 id=&quot;越州&quot;&gt;越州&lt;/h4&gt;
&lt;p&gt;越州位于东陆南块，面积约十二万拓，在东陆四州中列于第三。越州中部和西部地区以丘陵和低山为主，雷眼、北邙山脉诸多延伸山脉呈绵延不断的岭脊，主要是块状山，峰峦耸立，山坡陡峭，岩石裸露，地形十分崎岖，山岭间错纵地分布着面积不大的山谷和盆地，盆地中水源丰富，东部和北部沿岸为海岸平原，沿海沙洲、潟湖较多，东南部还有珊瑚礁海岸。 越州的基本植被是硬叶常绿群落，不限于分布在沿海和平原地区，并沿河谷深入到山地内部，由于越州是人口最稀少的地区，全境森林覆盖率达到60％至70％。&lt;/p&gt;

&lt;h3 id=&quot;西陆&quot;&gt;西陆&lt;/h3&gt;
&lt;h4 id=&quot;云州&quot;&gt;云州&lt;/h4&gt;
&lt;p&gt;面积均约十二万拓，与雷州以中部被称为沉沙海的海湾为界。由于云州西部为高耸的赤华山脉，东部有丘陵群，地势较高，天高云远，所以中部有连片沙漠，与山谷交错着。&lt;/p&gt;

&lt;h3 id=&quot;雷州&quot;&gt;雷州&lt;/h3&gt;
&lt;p&gt;面积约十三万拓。与云州截然不同，气候调和，植物茂盛多样，两边临海，气候多雨潮湿，森林茂密。&lt;/p&gt;

&lt;h2 id=&quot;种族&quot;&gt;种族&lt;/h2&gt;

&lt;h3 id=&quot;人族&quot;&gt;人族&lt;/h3&gt;
&lt;h3 id=&quot;羽族&quot;&gt;羽族&lt;/h3&gt;
&lt;h3 id=&quot;夸父&quot;&gt;夸父&lt;/h3&gt;
&lt;h3 id=&quot;河络&quot;&gt;河络&lt;/h3&gt;
&lt;h3 id=&quot;鲛人&quot;&gt;鲛人&lt;/h3&gt;
&lt;h3 id=&quot;魅族&quot;&gt;魅族&lt;/h3&gt;</content><author><name>Tesla Lee</name></author><summary type="html">九州设定</summary></entry><entry><title type="html">Query DSL of Elasticsearch</title><link href="http://localhost:4000/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html" rel="alternate" type="text/html" title="Query DSL of Elasticsearch" /><published>2018-05-04T00:00:00+08:00</published><updated>2018-05-04T00:00:00+08:00</updated><id>http://localhost:4000/elasticsearch/2018/05/04/query-dsl-of-elasticsearch</id><content type="html" xml:base="http://localhost:4000/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html">&lt;p&gt;Elasticsearch 查询 DSL 基础知识&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;query-dsl&quot;&gt;Query DSL&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf query clauses（子查询）：在一个特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt; 查询特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 查询。&lt;/li&gt;
  &lt;li&gt;Compound query clauses（组合查询）：将子查询或组合查询再组合起来，例如，使用逻辑（&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;dis_max&lt;/code&gt;)，或者改变查询的行为（&lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Query clauses behave differently depending on whether they are used in query context or filter context.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;query-and-filter-context&quot;&gt;Query and filter context&lt;/h2&gt;

&lt;p&gt;The behaviour of a query clause depends on whether it is used in query context or in filter context:&lt;/p&gt;

&lt;h3 id=&quot;query-context&quot;&gt;Query context&lt;/h3&gt;
&lt;p&gt;A query clause used in query context answers the question “&lt;strong&gt;How well does this document match this query clause?&lt;/strong&gt;”.The query clause also calculates a _score representing how well the document matches, relative to other documents.&lt;/p&gt;

&lt;h3 id=&quot;filter-context&quot;&gt;Filter Context&lt;/h3&gt;
&lt;p&gt;In filter context, a query clause answers the question “&lt;strong&gt;Does this document match this query clause?&lt;/strong&gt;”&lt;/p&gt;

&lt;p&gt;Frequently used filters will be cached automatically by Elasticsearch, to speed up performance.&lt;/p&gt;

&lt;p&gt;Filter context is in effect whenever a query clause is passed to a filter parameter, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;must_not&lt;/code&gt; parameters in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; query, the filter parameter in the &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt; query, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; aggregation.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_search&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;query&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;must&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Search&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Elasticsearch&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;filter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;term&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;published&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;range&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;publish_date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gte&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-01-01&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; 指 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 和两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt; 使用，来评价每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt; 的评分&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 语句是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt; 中使用，他们用来筛选 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题：&lt;code class=&quot;highlighter-rouge&quot;&gt;Filter context&lt;/code&gt; 是在计算 score 前执行还是在计算 score 后执行？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;match-all-query&quot;&gt;Match all query&lt;/h2&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match_all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;匹配所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，并且给它们一个默认分数 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;full-text-queries&quot;&gt;Full text queries&lt;/h2&gt;
&lt;p&gt;The high-level full text queries are usually used for running full text queries on full text fields like the body of an email.They understand how the field being queried is analyzed and will apply each field’s analyzer (or search_analyzer) to the query string before executing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; query: 单个基础全文搜索，包括模糊、短语或近似查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi_match&lt;/code&gt; query: 多个字段的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;common_terms&lt;/code&gt; query: 更特殊的查询，用于处理一些不常用的词&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query_string&lt;/code&gt; query: Supports the compact Lucene query string syntax, allowing you to specify AND&lt;/td&gt;
          &lt;td&gt;OR&lt;/td&gt;
          &lt;td&gt;NOT conditions and multi-field search within a single query string. For expert users only.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple_query_string&lt;/code&gt;: A simpler, more robust version of the query_string syntax suitable for exposing directly to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;match-query&quot;&gt;Match Query&lt;/h3&gt;

&lt;h4 id=&quot;boolean&quot;&gt;boolean&lt;/h4&gt;

&lt;p&gt;默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询是 &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 查询 DSL 基础知识</summary></entry><entry><title type="html">Basic Concept of Elasticsearch</title><link href="http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html" rel="alternate" type="text/html" title="Basic Concept of Elasticsearch" /><published>2018-05-03T00:00:00+08:00</published><updated>2018-05-03T00:00:00+08:00</updated><id>http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch</id><content type="html" xml:base="http://localhost:4000/elasticsearch/2018/05/03/basic-concept-of-elasticsearch.html">&lt;p&gt;Elasticsearch 中的几个基本概念&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Near Realtime(NRT)&lt;/strong&gt;：接近实时，意味着，当你将内容存储到 Elasticsearch 后，大概最多一秒钟后就可以搜索了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cluster&lt;/strong&gt;：集群是一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;，并且在此基础上提供索引与搜索等功能。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Node&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 就是一个集群中的单台服务器，它存储数据，参与整个集群的数据索引和搜索功能。一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 在启动时会加入到指定的集群中去。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是一组有特定属性的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Documents&lt;/code&gt;。比如，你可以有个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放客户数据的，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 是存放产品目录。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：对于一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;，你可以指定一个或多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;，你自己可以赋予它任何意义。一般来说，比如多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 有相同的几个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt;，那么它们可以认为是一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Type&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Document&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt; 是能够被索引的基本单元。比如，一个客户有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Document&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Shards &amp;amp; Replicas&lt;/strong&gt;：一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 存储的数据可能会非常庞大， 以至于单台机器并没有办法存放这些数据。
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt;：为了解决这个问题，所以引入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 来将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 分成多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt;，每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 可以认为是一个独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt;。我们在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;Index&lt;/code&gt; 时，可以指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的数量。&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 提供了以下两个主要功能：
        &lt;ul&gt;
          &lt;li&gt;可以将你的内容平行分割扩展&lt;/li&gt;
          &lt;li&gt;可以提供分布式并行操作&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的管理完全由 Elasticsearch 接手。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Replica&lt;/strong&gt;：任何系统都需要有失败恢复机制。而 &lt;strong&gt;Replica&lt;/strong&gt; 或者 &lt;strong&gt;Replica Shard&lt;/strong&gt; 就提供这样的功能，它是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 的备份。它提供两个主要功能。
        &lt;ul&gt;
          &lt;li&gt;当一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard/Node&lt;/code&gt; 出错时，依然可以保持功能完整。所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;Replica&lt;/code&gt; 与 原 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 永远不会存放在同一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt; 上面。&lt;/li&gt;
          &lt;li&gt;它可以帮助扩展你的搜索数据量，因为所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Shard&lt;/code&gt; 都会被搜索到。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 中的几个基本概念</summary></entry><entry><title type="html">Chapter 2 - Lexical Analysis</title><link href="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html" rel="alternate" type="text/html" title="Chapter 2 - Lexical Analysis" /><published>2018-04-26T00:00:00+08:00</published><updated>2018-04-26T00:00:00+08:00</updated><id>http://localhost:4000/compiler/2018/04/26/lexical-analysis</id><content type="html" xml:base="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html">&lt;p&gt;『Modern Compiler Implementation in C』词法分析部分笔记和总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;lex-i-cal&lt;/strong&gt; : of or relating to words or the vocabulary of a language as distinguished from its grammar and construction&lt;/p&gt;

  &lt;p&gt;— Webster’s Dictionary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要将程序从一种语言翻译到另一种语言，编译器要先将程序处理成&lt;strong&gt;片段&lt;/strong&gt;，并理解其&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;意义&lt;/strong&gt;，然后将片段重新再组合。编译器前端负责&lt;strong&gt;分析&lt;/strong&gt;，而后端负责&lt;strong&gt;整合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;分析工作主要:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析（Lexical analysis）：将输入识别成词素，既（Lexical Token）&lt;/li&gt;
  &lt;li&gt;语法分析（Syntax analysis）：分析程序的结构&lt;/li&gt;
  &lt;li&gt;语义分析（Semantic analysis）：计算出程序的意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;词法分析器输入字符流，输出词，关键字，符号等。&lt;/p&gt;

&lt;h2 id=&quot;lexical-tokens词素&quot;&gt;LEXICAL TOKENS（词素）&lt;/h2&gt;
&lt;p&gt;Lexical token 是一个字符序列，它是一门语言的最小语法元素。一门编程语言的 token 类型，是一个有限集合。&lt;/p&gt;

&lt;h3 id=&quot;例如&quot;&gt;例如：&lt;/h3&gt;

&lt;p&gt;Token 类型 例子&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; foo n14, last&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NUM&lt;/code&gt; 74 0 00 082&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;REAL&lt;/code&gt; 66.1 .5 10. 1e66 5.5e-10&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; if&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; ,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NOTEQ&lt;/code&gt; !=&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; (&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 if，void，这样的符号，我们称之为&lt;strong&gt;保留字&lt;/strong&gt;，在大部分语言里，保留字不能作为 ID 来使用。除了上面这些 Token 以外，字符流中还有非 token 内容。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注释  /* try again */&lt;/li&gt;
  &lt;li&gt;预处理 #include &lt;stdio.h&gt;&lt;/stdio.h&gt;&lt;/li&gt;
  &lt;li&gt;预处理 #define NUMS 5 , 6&lt;/li&gt;
  &lt;li&gt;宏 NUMS&lt;/li&gt;
  &lt;li&gt;空格，换行，缩进等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;弱语言需要有一个宏预处理器，宏预处理去先操作输入流，进行预处理，生成新的字符流输出给词法分析器。当然，也可以直接将宏预处理器集成到词法分析器中去。&lt;/p&gt;

&lt;p&gt;比如有这样一段代码：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* find a zero */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;match0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;0.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;词法分析器在输入这段代码后，会输出：
&lt;code class=&quot;highlighter-rouge&quot;&gt;FLOAT&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(match0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;CHAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STAR&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;IF&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;BAND&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(strncmp)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;LPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ID(s)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;COMMA&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;NUM(3)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RPAREN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RETURN&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;REAL(0.0)&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;SEMI&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;RBRACE&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;EOF&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;从上面的输出我们可以看到，每一个输出的 Token 都有类型。其中，像 &lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;STRING&lt;/code&gt; 等会带有值来提供额外的信息。&lt;/p&gt;

&lt;p&gt;那么，接下来的问题是，我们用什么来描述 Token 的规则？用什么语言来实现词法分析器？我们完全可以使用自然语言来直接描述规则，比如下面这样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;标识符（ID）&lt;/code&gt;是由字母和数字组成的字符序列，首个字符必须是字母开头。同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 下划线也认为是字母。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同时,我们也可以使用任意合适的语言去实现词法分析器。不过，在这里，我们会使用&lt;strong&gt;正则表达式&lt;/strong&gt;来描述词法规则，用&lt;strong&gt;确定性有限自动机&lt;/strong&gt;来实现，同时，还会使用&lt;strong&gt;数学语言&lt;/strong&gt;来将这两者联系起来。&lt;/p&gt;

&lt;h2 id=&quot;regular-expression正则表达式&quot;&gt;REGULAR EXPRESSION（正则表达式）&lt;/h2&gt;
&lt;p&gt;一门语言，是一个字符串的集合；字符串是符号的有限序列；符号来自一个优先符号集合。我们这样描述一门语言时，并没有赋予字符串以任何意义，我们只是去区分字符串是否属于这门语言。为了能够仅仅使用有限的规则来描述一门语言，我们使用&lt;strong&gt;正则表达式&lt;/strong&gt;来标记这些规则。每一条&lt;strong&gt;正则表达式&lt;/strong&gt;表示一组字符串。&lt;/p&gt;

&lt;p&gt;下面是正则表达式的基本规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Symbol（符号）&lt;/strong&gt;：对于每一个符号 &lt;strong&gt;a&lt;/strong&gt; ，直接表示字符串 &lt;strong&gt;a&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Alternation（选择）&lt;/strong&gt;：对于 $M \mid N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Concatenation（连续，连接）&lt;/strong&gt;：$M \ast N$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Epsilon（空）&lt;/strong&gt;：$\epsilon$&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Repetition（重复）&lt;/strong&gt;：重复一次，重复多次，至少重复一次&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kleene closure: Given a regular expression M, its Kleene closure is $M^*$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用以上这些基本规则，我们就可以来表示由 ASCII 字符组成的变成语言了。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(0 \mid 1)^\ast \ast 0$ 表示任意能被 2 整除的二进制数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$ : 普通字符&lt;/li&gt;
  &lt;li&gt;$\epsilon$ : 空字符串&lt;/li&gt;
  &lt;li&gt;$M \mid N$ : 选择 M 或 N&lt;/li&gt;
  &lt;li&gt;$M \bullet N$ (MN) : 连接&lt;/li&gt;
  &lt;li&gt;$M^\ast$ : 重复出现零次或多次&lt;/li&gt;
  &lt;li&gt;$M^+$ : 重复出现一次或多次&lt;/li&gt;
  &lt;li&gt;$M?$ : 出现一次或者不出现&lt;/li&gt;
  &lt;li&gt;$[a-zA-Z]$: 再大小写字母中选择&lt;/li&gt;
  &lt;li&gt;$\bullet$ : 表示任意字符&lt;/li&gt;
  &lt;li&gt;“$a.+^\ast$” : 精确匹配完成字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入正则表达式后，我们就可以来描述词法规则了&lt;/p&gt;

&lt;p&gt;假如有下面这样的 C 代码片段：&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;REAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;--&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* do nothing */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有关键字 &lt;strong&gt;if&lt;/strong&gt;，标识符 &lt;strong&gt;ID&lt;/strong&gt;，数字 &lt;strong&gt;NUM&lt;/strong&gt;，以及实数 &lt;strong&gt;REAL&lt;/strong&gt;，还定义了注释 『–』开头的单行注释。第五行是注释，意味着词法分析器会跳过它们继续执行，同时，词法分析器应该是功能完整的。它应该能够处理所有的符号，包括错误的。&lt;/p&gt;

&lt;p&gt;写到这里，我们很快会注意到一个问题：&lt;strong&gt;IF&lt;/strong&gt; 和 &lt;strong&gt;ID&lt;/strong&gt; 这两个规则是有交集的。在没有假如更多规则的情况下，我们如何去识别 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 到底是 &lt;strong&gt;ID token&lt;/strong&gt; 还是 &lt;strong&gt;IF token&lt;/strong&gt;？再比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是先匹配 &lt;strong&gt;IF&lt;/strong&gt; 规则还是先匹配 &lt;strong&gt;ID&lt;/strong&gt; 规则？&lt;/p&gt;

&lt;p&gt;下面引入两种常用的去歧义规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Longest match&lt;/strong&gt;：也就是最长匹配原则，规则所能匹配的最长子串作为下一个输出的 token。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rule priority&lt;/strong&gt;：规则优先级原则，对于一个最长子串，第一个能够匹配的规则所表示 token 作为输。这也就意味着，匹配的顺序是有意义且重要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入了这两个规则之后，我们就可以确定 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 是 &lt;strong&gt;IF&lt;/strong&gt; token 了，因为它最新匹配了 &lt;strong&gt;IF&lt;/strong&gt;，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;if8&lt;/code&gt; 是 &lt;strong&gt;ID&lt;/strong&gt; token.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;好了，到这里可以先简单的做一下总结。一门语言，有其最基本的语法元素，这里是 Lexical token。我们需要描述每一种 token 的规则，当然可以使用自然语言，但要让 Lexer 理解，必须要使用一种能实现成程序的方式。
于是我们引入了 Regular Expression 来描述词法规则。同时付加了两条消除歧义的规则，&lt;strong&gt;最长匹配&lt;/strong&gt;和&lt;strong&gt;匹配优先级&lt;/strong&gt;
那么，到这里我有一个疑问，&lt;strong&gt;是不是使用 Regular Expression 就足够实现词法分析了？&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finite-automata&quot;&gt;FINITE AUTOMATA&lt;/h2&gt;

&lt;p&gt;前面有个问题：有了&lt;strong&gt;正则表达式&lt;/strong&gt;，是不是就可以直接使用&lt;strong&gt;正则&lt;/strong&gt;来实现词法匹配了？毕竟大多数的语言都有&lt;strong&gt;正则&lt;/strong&gt;的实现。对的，用正则来实现词法分析器是完全没有问题的。&lt;/p&gt;

&lt;p&gt;这里我正好在网上搜到了 Rob Pike 一篇文章 &lt;a href=&quot;https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html&quot;&gt;Regular expression in lexing and parsing&lt;/a&gt;。摘取他的观点放在这里。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are hard to write, hard to write well, and can be expensive relative to other technologies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A regular expression library is a big thing. Using one to parse identifiers is like using a Mack truck to go to the store for milk. And when we want to adjust our lexer to admit other character types, such as Unicode identifiers, and handle normalization, and so on, the hand-written loop can cope easily but the regexp approach will break down.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Using regular expressions to explore the parse state to find the way forward is expensive, overkill, and error-prone.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are, in my experience, widely misunderstood and abused.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里我不深入这个问题，后面我会尝试实现一个基于&lt;strong&gt;正则表达式&lt;/strong&gt;的词法分析器。&lt;/p&gt;

&lt;h3 id=&quot;什么是有限自动机&quot;&gt;什么是有限自动机？&lt;/h3&gt;

&lt;p&gt;我们这里直接使用有限自动机来实现词法分析的功能。有限自动机由 &lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边&lt;/strong&gt;，&lt;strong&gt;符号&lt;/strong&gt; 组成，状态有 &lt;strong&gt;终结状态&lt;/strong&gt; 和 &lt;strong&gt;开始状态&lt;/strong&gt;。有限自动机是一种状态机，它通过状态转化来实现接受或者拒绝特定字符串的功能。这里直接摘取维基百科对于状态机的定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types - deterministic finite state machines and non-deterministic finite state machines.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The finite state machine has less computational power than some other models of computation such as the Turing machine.[2] The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM’s memory is limited by the number of states it has. FSMs are studied in the more general field of automata theory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，现在引入了有限自动机这个概念。
有限自动机可以很方便的是现成程序。
有限自动机由：&lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边（从一个状态到另一个状态）&lt;/strong&gt;，&lt;strong&gt;边上的符号&lt;/strong&gt;，&lt;strong&gt;开始状态&lt;/strong&gt; 和 &lt;strong&gt;终结状态&lt;/strong&gt; 组成。&lt;/p&gt;

&lt;p&gt;有限自动机分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA 确定性有限自动机：从一个状态接收，只有唯一确定的边指向另一个状态。&lt;/li&gt;
  &lt;li&gt;NFA 非确定性有限自动机：从一个状态接收，有多个不同的状态可以到达。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我们可以给上面的词法规则画出如下的几个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_1.png&quot; alt=&quot;Fig 2.3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们也可以写成一个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_2.png&quot; alt=&quot;Fig 2.4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;EXERCISES&lt;/h2&gt;

&lt;p&gt;2.1 Write regular expressions for each of the following.&lt;/p&gt;

&lt;p&gt;a. String over the alphabet $ \{ a,b,c \} $ where the first $a$ precedes the first $b$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：因为必须第一个 $a$ 出现在第一个 $b$ 后面，所以实际上只有两种情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;第一个 $a$ 前面只有 $c$&lt;/li&gt;
    &lt;li&gt;没有出现 $a$&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ c^\ast a[abc]^\ast \mid [bc]^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;b. String over the alphabet {a,b,c} with an even number of a’s.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：需要 $a$ 的个数是偶数个
同样也分解情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;两个 $a$ 连续出现&lt;/li&gt;
    &lt;li&gt;两个 $a$ 没有连续出现，中间有其他字符&lt;/li&gt;
    &lt;li&gt;可以为空
将上面的三种情况组合起来，得到答案&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ (a([bc]^\ast aa[bc]^\ast )^\ast a)^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;c. Binary numbers that are multiples of four.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$0\mid1^\ast00$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;d. Binary numbers that are greater than 101001.&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;e. String over the alphabet {a,b,c} that don’t contain the contiguous string baa.&lt;/p&gt;

&lt;p&gt;f. The language of nonnegative integer constants in C, where numbers beginning with 0 are octal constants and other numbers are decimal constants.&lt;/p&gt;

&lt;p&gt;g. Binary numbers n such that there exists an integer solution of $a^n + b^n = c^n$.&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">『Modern Compiler Implementation in C』词法分析部分笔记和总结。</summary></entry><entry><title type="html">Notes on Machine Learning on Coursera</title><link href="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html" rel="alternate" type="text/html" title="Notes on Machine Learning on Coursera" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera</id><content type="html" xml:base="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html">&lt;p&gt;I always want to learn Machine Learning and finally I got time.&lt;/p&gt;

&lt;p&gt;I first started with the open class CS 229 Machine Learning from Stanford by Andrew Ng. But I failed after 2 classes, because Andrew Ng skipped some math detail that I forget the knowledge of calculus and linear algebra.&lt;/p&gt;

&lt;p&gt;Then I find the Machine Learning by Andrew Ng on &lt;a href=&quot;http://www.coursera.com/&quot;&gt;Coursera&lt;/a&gt; is great.&lt;/p&gt;

&lt;p&gt;The learning curve of class is more gentle, and all math details are covered in the course.&lt;/p&gt;

&lt;p&gt;So if you want to learning machine learning, I highly recommend you try this course. All you want to know is the basic knowledge of calculus and linear algebra, which also covered in the course.&lt;/p&gt;

&lt;p&gt;Yeah!&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">I always want to learn Machine Learning and finally I got time.</summary></entry><entry><title type="html">《头号玩家》</title><link href="http://localhost:4000/2018/04/02/ready-player-one.html" rel="alternate" type="text/html" title="《头号玩家》" /><published>2018-04-02T00:00:00+08:00</published><updated>2018-04-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/02/ready-player-one</id><content type="html" xml:base="http://localhost:4000/2018/04/02/ready-player-one.html">&lt;p&gt;看完《头号玩家》后，有一个问题一直在脑海里盘旋：
『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』&lt;/p&gt;

&lt;p&gt;到刚才，在微博上看到梅原大吾用隆完全格挡春丽的大招时，我才忽然明白。&lt;/p&gt;

&lt;p&gt;《头号玩家》带给我的感觉：&lt;/p&gt;

&lt;p&gt;它瞬间把我拉回了童年，那个在一群人在家里，围着游戏机一起通关的场景。&lt;/p&gt;

&lt;p&gt;之所以喜悦是因为那种久违的感觉，而忧伤是，你知道永远也不会再回去了。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">看完《头号玩家》后，有一个问题一直在脑海里盘旋： 『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』</summary></entry><entry><title type="html">My New Rules of Life</title><link href="http://localhost:4000/2018/03/02/my-new-rules-of-life.html" rel="alternate" type="text/html" title="My New Rules of Life" /><published>2018-03-02T13:56:00+08:00</published><updated>2018-03-02T13:56:00+08:00</updated><id>http://localhost:4000/2018/03/02/my-new-rules-of-life</id><content type="html" xml:base="http://localhost:4000/2018/03/02/my-new-rules-of-life.html">&lt;p&gt;Rules&lt;/p&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;things-i-wont-do-in-the-future&quot;&gt;Things I won’t do in the future&lt;/h4&gt;

&lt;p&gt;1 Alchohol.&lt;/p&gt;

&lt;p&gt;2 Eating meat except chicken and fish.&lt;/p&gt;

&lt;p&gt;3 Cigarette.&lt;/p&gt;

&lt;p&gt;4 Fast food, sugure, carbonated soft drinks.&lt;/p&gt;

&lt;h4 id=&quot;things-i-want&quot;&gt;Things I want&lt;/h4&gt;

&lt;p&gt;1 Exercises.&lt;/p&gt;

&lt;p&gt;2 Sleep early and get up early.&lt;/p&gt;

&lt;p&gt;3 Reading.&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Rules</summary></entry><entry><title type="html">两部电影和下一步</title><link href="http://localhost:4000/2018/01/10/recent.html" rel="alternate" type="text/html" title="两部电影和下一步" /><published>2018-01-10T00:15:00+08:00</published><updated>2018-01-10T00:15:00+08:00</updated><id>http://localhost:4000/2018/01/10/recent</id><content type="html" xml:base="http://localhost:4000/2018/01/10/recent.html">&lt;p&gt;最近看了两部有意思的电影。《一日情人》和《三块广告牌》。&lt;/p&gt;

&lt;p&gt;《一日情人》是一部法国电影。工作后，就一直没有心思停下来看这样“絮絮叨叨”的电影了，好像，电影里所探讨的问题，琐碎得遥远。&lt;/p&gt;

&lt;p&gt;7 分吧，推荐喜欢这类电影的人看一看。&lt;/p&gt;

&lt;p&gt;这里放上几张好看的剧照：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2457077051.jpg&quot; alt=&quot;剧照1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2457077066.jpg&quot; alt=&quot;剧照2&quot; /&gt;
&lt;img src=&quot;/assets/images/p2494758206.jpg&quot; alt=&quot;剧照3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而另一部电影《三块广告牌》，则是刚刚过去的75届金球奖最佳剧情片得主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2510412903.jpg&quot; alt=&quot;海报1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2510431925.jpg&quot; alt=&quot;剧照1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部电影的剧情结构让我想起了几年前看的《Crash》。多个人物之间的冲突，以及人物，情节与大环境之间的相互影响，都像极了《Crash》。&lt;/p&gt;

&lt;p&gt;9 分推荐。&lt;/p&gt;

&lt;p&gt;同一位导演我还看过另一部作品《在布鲁日》（又名《杀手没有假期》），当时没有看得太明白，只是觉得非常有意思。&lt;/p&gt;

&lt;p&gt;关于我的下一步。在考虑了几天之后，我决定正式接受老陆的工作，完成 DearID 的项目。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">最近看了两部有意思的电影。《一日情人》和《三块广告牌》。</summary></entry><entry><title type="html">时间</title><link href="http://localhost:4000/2018/01/03/time.html" rel="alternate" type="text/html" title="时间" /><published>2018-01-03T23:05:00+08:00</published><updated>2018-01-03T23:05:00+08:00</updated><id>http://localhost:4000/2018/01/03/time</id><content type="html" xml:base="http://localhost:4000/2018/01/03/time.html">&lt;p&gt;对于一个人而言，过去的生活到底意味着什么？时间又是什么？&lt;/p&gt;

&lt;p&gt;2016 年我失去了一位很重要的亲人，但是现在去回忆，当时所有的痛苦都变得平淡了。那么，那些原本经历的事情最后变成了什么？&lt;/p&gt;

&lt;p&gt;时间不是连续的，因为人的大脑和经验不是连续的。时间一旦消失，人对于时间的感知就消失了。反过来也可以认为，对于未来时间的感知实际上也是虚假的。如果我们迫切的希望眼前的时间快速的过去，那意味着对于即将到来的事情而言，此时此刻是不重要的。&lt;/p&gt;

&lt;p&gt;但是，如果此时此刻是不重要的，那为什么即将到来的事情是重要的？我的意思是，为什么可以不在乎此时此刻而更加在乎即将到来的事情？&lt;/p&gt;

&lt;p&gt;但是，假设一种极端情况，如果24小时后我要被枪决，或者我知道自己的生命只剩几个月了。也就是说，将要到来的一件事，不只是非常重要，而是直接结束了一切。那么，此时此刻还重要吗？我以什么样的方式过，做什么事情还重要吗？如果不重要，为什么50年就是重要的？因为时间的长度吗？&lt;/p&gt;

&lt;p&gt;我已经坚信一个结论：时间的长度本身是不重要的。50年和50天之间的区别只在于这段时间内做的事情。如果 50 天我去了马丘比丘，去了埃及，去了复活节岛。而 50 年里，我追求安全感的生活让我什么都没做，想去的地方，想做的事情一件也没有达成。那显然我会选择 50 天。&lt;/p&gt;

&lt;p&gt;但我并不是要去藐视时间，觉得时间（生命）是不重要的，我太希望那位离开的亲人活得更久一点了。&lt;/p&gt;

&lt;p&gt;时间好像是一种介质，它将我们（做的事情，经历）与（我们的）生活联系起来，从而赋予（我们的）生命以意义。所以，“怎么利用时间？”这个问题的重点其实是，在时间中我们做什么？因为时间是没有办法控制的，无论我们做什么，做多做少，时间最后都会消失，能控制的只是“做什么”。&lt;/p&gt;

&lt;p&gt;所以，“现在做什么”比什么都重要。&lt;/p&gt;

&lt;p&gt;下一个问题：怎么决定“现在做什么”？&lt;/p&gt;

&lt;p&gt;前两天看到了贝索斯在亚马逊早起的一个采访。当时亚马逊应该已经是一个有所成就的图书销售网站了，所以，贝索斯可以认为是一个成功的人了，至少再外界看来。所以，在采访中，主持人问贝索斯说，“我以为你会是一个享受当下的人”。贝索斯非常干脆的回答了这个问题，说他不是这样的人，他做事遵循的原则是，“最小后悔原则”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;，这个词我是第一次听说，当然，一听到就觉得非常有道理。&lt;/p&gt;

&lt;p&gt;但是随之而来产生了几个疑问是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;的目标是什么？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从采访中，可以看出，至少贝索斯认为现在虽然已经是还算成功的状态了，但是在他能看到的地方，还有更重要的事情去做。所以，为了达到这个目的，此时此刻，享受当下是非常愚蠢的。&lt;/p&gt;

&lt;p&gt;所以，要能看到“未来”。要大概的知道“未来”的样子，然后为之制定一套行为标准，其实并不需要清晰的知道“未来”，因为谁也不可能清楚的预测。但是，通过想象未来的样子，可以看到方向。比如，我并不知道未来具体是什么情景，但是大概知道我想要去日本，所以现在开始学好日语就是一条&lt;strong&gt;最小后悔原则&lt;/strong&gt;。其实，另一个问题也有了：&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？那就是在此时此刻尽力了。&lt;/p&gt;

&lt;p&gt;但是这个“尽力”并不是精疲力劲的意思，精疲力劲实际上意味着透支未来，以一种低效的方式去话费未来的时间。尽力，可以认为是相对努力，已目前能达到的最大状态工作，但又不至于过于疲惫。&lt;/p&gt;

&lt;p&gt;所以，决定“此时此刻”的是未来，但创造未来的，确实“此时此刻”。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">对于一个人而言，过去的生活到底意味着什么？时间又是什么？</summary></entry><entry><title type="html">Deathland Studio 开张</title><link href="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html" rel="alternate" type="text/html" title="Deathland Studio 开张" /><published>2018-01-01T15:26:33+08:00</published><updated>2018-01-01T15:26:33+08:00</updated><id>http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio</id><content type="html" xml:base="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html">&lt;p&gt;今天 2018 年的第一天，Deathland Studio 工作室正式成立。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/deathland_studio_logo.jpeg&quot; alt=&quot;Logo&quot; /&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">今天 2018 年的第一天，Deathland Studio 工作室正式成立。</summary></entry></feed>