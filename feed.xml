<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://www.teslalee.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.teslalee.com/" rel="alternate" type="text/html" /><updated>2018-05-09T19:05:19+08:00</updated><id>http://www.teslalee.com/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">Elasticsearch - Inverted Index</title><link href="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Inverted-Index.html" rel="alternate" type="text/html" title="Elasticsearch - Inverted Index" /><published>2018-05-09T18:40:20+08:00</published><updated>2018-05-09T18:40:20+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Inverted-Index</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Inverted-Index.html">&lt;p&gt;倒排索引 Inverted Index&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&quot;&gt;维基词条&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;倒排索引（英语：Inverted index），也常被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;反向索引&lt;/code&gt;、置&lt;code class=&quot;highlighter-rouge&quot;&gt;入档案&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;反向档案&lt;/code&gt;，是一种索引方法，被用来存储在全文搜索下某个单词在&lt;code class=&quot;highlighter-rouge&quot;&gt;一个文档&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;一组文档&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;存储位置的映射&lt;/code&gt;。它是文档检索系统中最常用的数据结构。&lt;/p&gt;

&lt;p&gt;有两种不同的反向索引形式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一条记录的水平反向索引（或者反向档案索引）包含每个引用单词的文档的列表。&lt;/li&gt;
  &lt;li&gt;一个单词的水平反向索引（或者完全反向索引）又包含每个单词在一个文档中的&lt;strong&gt;位置&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;例子&quot;&gt;例子&lt;/h2&gt;

&lt;p&gt;以英文为例&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$T_0$ = “it is what it is&lt;/p&gt;

  &lt;p&gt;$T_1$ = “waht is it”&lt;/p&gt;

  &lt;p&gt;$T_2$ = “it is a banana”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;就有以下反向文件索引：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a&quot;:      {2}
&quot;banana&quot;: {2}
&quot;is&quot;:     {0, 1, 2}
&quot;it&quot;:     {0, 1, 2}
&quot;what&quot;:   {0, 1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;检索 “what”, “is”, “it” 时，可以得到对应的集合：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$\{ 0,1 \} \cap \{ 0, 1, 2 \} \cap \{ 0,1,2 \} = \{ 0,1 \}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同样的，我们还能建立一个完全反向索引&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;a&quot;:      {(2, 2)}
&quot;banana&quot;: {(2, 3)}
&quot;is&quot;:     {(0, 1), (0, 4), (1, 1), (2, 1)}
&quot;it&quot;:     {(0, 0), (0, 3), (1, 2), (2, 0)}
&quot;what&quot;:   {(0, 2), (1, 0)}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于 “what is it”&lt;/p&gt;

&lt;p&gt;其完全索引就是{(1, 1), (1, 2), (1, 0)} 可以看到，只有在文档1 中，两个词是连续的。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">倒排索引 Inverted Index</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 6</title><link href="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-6.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 6" /><published>2018-05-09T17:46:51+08:00</published><updated>2018-05-09T17:46:51+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-6</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-6.html">&lt;p&gt;映射与分析&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;在我们的先有数据中，有一条数据的 date 是 2014-09-23。但是我们发现在使用查询&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. GET /_search?q=2014    # 13
2. GET /_search?q=date:2014 # 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;时，没有得到我们想要的结果，返回的文档数是 0。为什么？&lt;/p&gt;

&lt;p&gt;我们知道，第一条查询，是搜索的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_all&lt;/code&gt; 字段，第二条查询，搜索的 &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;_all&lt;/code&gt; 字段的类型是 &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;，但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt; 字段是什么类型，却不清楚。&lt;/p&gt;

&lt;p&gt;可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;GET /gb/_mapping/tweet&lt;/code&gt; 文档的结构与类型。&lt;/p&gt;

&lt;p&gt;可以看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt; 字段是 &lt;code class=&quot;highlighter-rouge&quot;&gt;strict_date_optional_time||epoch_millis&lt;/code&gt; 类型。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">映射与分析</summary></entry><entry><title type="html">Elasticsearch - Index vs Type</title><link href="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Index-vs-Type.html" rel="alternate" type="text/html" title="Elasticsearch - Index vs Type" /><published>2018-05-09T16:43:35+08:00</published><updated>2018-05-09T16:43:35+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Index-vs-Type</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-Index-vs-Type.html">&lt;p&gt;This article is a short and noted versions of elasticsearch’s  &lt;a href=&quot;https://www.elastic.co/blog/index-vs-type&quot;&gt;Index vs Type&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;what-is-an-index&quot;&gt;What is an index?&lt;/h2&gt;
&lt;p&gt;An index is stored in a set of shards, which are themselves Lucene indices.&lt;/p&gt;

&lt;p&gt;Lucene indices have a small yet fixed overhead in terms of disk space, memory usage and file descriptors used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a single large index is more efficient than several small indices.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;While each shard is searched independently, Elasticsearch eventually needs to merge results from all the searched shards.&lt;/p&gt;

&lt;p&gt;So, if the request is heavy, the task of merging all these shard results can become very resource-intensive, both in terms of CPU and memory.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-type&quot;&gt;What is a type?&lt;/h2&gt;

&lt;p&gt;Types are a convenient way to store several types of data in the same index, in order to keep the total number of indices low for the reasons exposed above.&lt;/p&gt;

&lt;h3 id=&quot;limitations&quot;&gt;limitations&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Fields need to be consistent across types. For instance if two fields have the same name in different types of the same index, they need to be of the same field type (string, date, etc.) and have the same configuration.&lt;/li&gt;
  &lt;li&gt;Fields that exist in one type will also consume resources for documents of types where this field does not exist. &lt;strong&gt;for speed reasons, doc values often reserve a fixed amount of disk space for every document, so that values can be addressed efficiently.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Scores use index-wide statistics, so scores of documents in one type can be impacted by documents from other types.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">This article is a short and noted versions of elasticsearch’s Index vs Type</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 5</title><link href="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-5.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 5" /><published>2018-05-09T16:15:11+08:00</published><updated>2018-05-09T16:15:11+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-5</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/09/Elasticsearch-The-Definitive-Guide-Chapter-5.html">&lt;p&gt;搜索 —— 最基本的工具&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;基本概念：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;映射（Mapping）&lt;/code&gt;描述数据在每个字段内如何存储&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;分析（Analysis）&lt;/code&gt;全文是如何处理是指可以被搜索的&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;领域特定查询语言（Query DSL）&lt;/code&gt;Elasticsaerch 中强大灵活的查询语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;空搜索&quot;&gt;空搜索&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/_search&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个简化的返回：&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hits&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;total&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hits&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;us&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tweet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_score&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_source&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
             &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2014-09-17&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
             &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;John Smith&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
             &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tweet&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;The Query DSL is really powerful and flexible&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
             &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;user_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
       &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;RESULTS&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;REMOVED&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;max_score&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;took&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;           &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_shards&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;failed&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;successful&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;total&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;       &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;timed_out&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;hits&quot;&gt;hits&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;：匹配到的总文档数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hits&lt;/code&gt; 数组：前 10 个文档&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_score&lt;/code&gt;：衡量每个文档的匹配度。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max_score&lt;/code&gt;: 所有匹配文档中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_score&lt;/code&gt; 的最大值。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;took&quot;&gt;took&lt;/h3&gt;
&lt;p&gt;整个搜索耗时多少&lt;strong&gt;毫秒&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;shards&quot;&gt;shards&lt;/h3&gt;
&lt;p&gt;查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。&lt;/p&gt;

&lt;h3 id=&quot;timeout&quot;&gt;timeout&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timed_ount&lt;/code&gt; 查询是否超时。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt; 不是停止执行查询，它仅仅是告知正在协调的节点返回到目前为止收集的结果并且关闭连接。在后台，其他的分片可能仍在执行查询即使是结果已经被发送了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多索引多类型&quot;&gt;多索引，多类型&lt;/h2&gt;
&lt;p&gt;我们可以通过在URL中指定特殊的索引和类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/_search&lt;/code&gt;在所有的索引中搜索所有的类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/gb/_search&lt;/code&gt;在 gb 索引中搜索所有的类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/gb,us/_search&lt;/code&gt;在 gb 和 us 索引中搜索所有的文档&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/g*,u*/_search&lt;/code&gt;在任何以 g 或者 u 开头的索引中搜索所有的类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/gb/user/_search&lt;/code&gt;在 gb 索引中搜索 user 类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/gb,us/user,tweet/_search&lt;/code&gt;在 gb 和 us 索引中搜索 user 和 tweet 类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/_all/user,tweet/_search&lt;/code&gt;在所有的索引中搜索 user 和 tweet 类型&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;分页&quot;&gt;分页&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;from&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt; 参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;显示应该返回的结果数量，默认是 10&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;from&lt;/code&gt;显示应该跳过的初始结果数量，默认是 0&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;轻量搜索&quot;&gt;轻量搜索&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;轻量搜索&lt;/strong&gt;，在查询字符串中传递参数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;完整搜索&lt;/strong&gt;，使用 JSON 或更丰富的请求体&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;_all-字段&quot;&gt;_all 字段&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /_search?q=mary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的查询是如何执行的？
我们会发现， Elasticsearch 返回的结果中，所有字段中包含 mary 的文档都返回了。这是因为，Elasticsearch 在索引文档时，会将所有的字段拼成一个字段 &lt;code class=&quot;highlighter-rouge&quot;&gt;_all&lt;/code&gt;，进行索引。就好像多了一个字段 &lt;code class=&quot;highlighter-rouge&quot;&gt;_all&lt;/code&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">搜索 —— 最基本的工具</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 4</title><link href="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 4" /><published>2018-05-08T19:03:50+08:00</published><updated>2018-05-08T19:03:50+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-4.html">&lt;p&gt;分布式文档存储&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;路由一个文档到一个分片中&quot;&gt;路由一个文档到一个分片中&lt;/h2&gt;
&lt;p&gt;当索引一个文档的时候，文档会被存储到一个主分片中。&lt;/p&gt;

&lt;p&gt;如何决定存储在哪个分片中？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shard = hash(routing) % number_of_primary_shards&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 &lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt; 函数生成一个数字，然后这个数字再除以 &lt;code class=&quot;highlighter-rouge&quot;&gt;number_of_primary_shards&lt;/code&gt; （主分片的数量）后得到 余数 。&lt;/p&gt;

&lt;p&gt;所有的文档 API（ &lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;bulk&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;mget&lt;/code&gt; ）都接受一个叫做 &lt;code class=&quot;highlighter-rouge&quot;&gt;routing&lt;/code&gt; 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。&lt;/p&gt;

&lt;h2 id=&quot;主分片和副本分片如何交互&quot;&gt;主分片和副本分片如何交互&lt;/h2&gt;
&lt;p&gt;假设有一个三个节点的集群，包含一个叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;blogs&lt;/code&gt; 的索引。有两个主分片和四个副分片。
则分片的分布可能如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0401.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们假设下面的请求，都发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 上。&lt;/p&gt;

&lt;h2 id=&quot;新建索引和删除文档&quot;&gt;新建、索引和删除文档&lt;/h2&gt;
&lt;p&gt;新建、索引和删除 请求都是 写 操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个文档只能存在于一个分片中，也就是说，如果一个索引有两个主分片，可以认为两个主分片合起来存储了索引的所有文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更新步骤：
&lt;img src=&quot;/assets/images/elas_0402.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送新建、索引或者删除请求。&lt;/li&gt;
  &lt;li&gt;节点使用文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 确定文档属于分片 0 。请求会被转发到&lt;code class=&quot;highlighter-rouge&quot;&gt; Node 3&lt;/code&gt;，因为分片 0 的主分片目前被分配在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 上。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 在主分片上面执行请求。如果成功了，它将请求并行转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 的副本分片上。一旦所有的副本分片都报告成功, &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 将向协调节点报告成功，协调节点向客户端报告成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在客户端收到成功响应时，文档变更&lt;strong&gt;已经在主分片和所有副本分片执行完成&lt;/strong&gt;，变更是安全的。&lt;/p&gt;

&lt;p&gt;一些可选参数：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;consistency&lt;/code&gt;：consistency，即一致性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在默认设置下，即使仅仅是在试图执行一个_写_操作之前，主分片都会要求 必须要有 &lt;em&gt;规定数量(quorum)&lt;/em&gt;（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行_写_操作(其中分片副本可以是主分片或者副本分片)。
_规定数量_ 计算公式: &lt;code class=&quot;highlighter-rouge&quot;&gt;int( (primary + number_of_replicas) / 2 ) + 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;consistency&lt;/code&gt; 参数的值可以设为 &lt;code class=&quot;highlighter-rouge&quot;&gt;one&lt;/code&gt; （只要主分片状态 ok 就允许执行_写_操作）,&lt;code class=&quot;highlighter-rouge&quot;&gt;all&lt;/code&gt;（必须要主分片和所有副本分片的状态没问题才允许执行_写_操作）, 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;quorum&lt;/code&gt; 。默认值为 &lt;code class=&quot;highlighter-rouge&quot;&gt;quorum&lt;/code&gt; , 即大多数的分片副本状态没问题就允许执行_写_操作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果没有足够的副本分片会发生什么？ Elasticsearch会等待，希望更多的分片出现。默认情况下，它最多等待1分钟。 如果你需要，你可以使用 timeout 参数 使它更早终止： 100 100毫秒，30s 是30秒。&lt;/p&gt;

&lt;h2 id=&quot;取回一个文档&quot;&gt;取回一个文档&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0403.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送获取请求。&lt;/li&gt;
  &lt;li&gt;节点使用文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 来确定文档属于分片 0 。分片 0 的副本分片存在于所有的三个节点上。 在这种情况下，它将请求转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2 &lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 将文档返回给 Node 1 ，然后将文档返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;局部更新文档&quot;&gt;局部更新文档&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0404.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送更新请求。&lt;/li&gt;
  &lt;li&gt;它将请求转发到主分片所在的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 从主分片检索文档，修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;_source&lt;/code&gt; 字段中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; ，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试步骤 3 ，超过 &lt;code class=&quot;highlighter-rouge&quot;&gt;retry_on_conflict&lt;/code&gt; 次后放弃。&lt;/li&gt;
  &lt;li&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 成功地更新文档，它将新版本的文档并行转发到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 2&lt;/code&gt; 上的副本分片，重新建立索引。 一旦所有副本分片都返回成功， &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 3&lt;/code&gt; 向协调节点也返回成功，协调节点向客户端返回成功。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果Elasticsearch仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多文档模式&quot;&gt;多文档模式&lt;/h2&gt;
&lt;p&gt;协调节点知道每个文档存在于哪个分片中。 它将整个多文档请求分解成 每个分片 的多文档请求，并且将这些请求并行转发到每个参与节点。&lt;/p&gt;

&lt;p&gt;协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。
&lt;img src=&quot;/assets/images/elas_0405.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;mget&lt;/code&gt; 请求。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，&lt;code class=&quot;highlighter-rouge&quot;&gt; Node 1&lt;/code&gt; 构建响应并将其返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;同时，可以对 docs 数组中每个文档设置 routing 参数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/elas_0406.png&quot; alt=&quot;图片&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;客户端向 &lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 发送 &lt;code class=&quot;highlighter-rouge&quot;&gt;bulk&lt;/code&gt; 请求。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node 1&lt;/code&gt; 为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。&lt;/li&gt;
  &lt;li&gt;主分片一个接一个按顺序执行每个操作。当每个操作成功时，主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。 一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Tesla Lee</name></author><summary type="html">分布式文档存储</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 3</title><link href="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 3" /><published>2018-05-08T15:09:15+08:00</published><updated>2018-05-08T15:09:15+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/08/Elasticsearch-The-Definitive-Guide-Chapter-3.html">&lt;p&gt;数据输入和输出&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;一个 对象 是基于特定语言的内存的数据结构。 为了通过网络发送或者存储它，我们需要将它表示成某种标准的格式。 JSON 是一种以人可读的文本表示对象的方法。 它已经变成 NoSQL 世界交换数据的事实标准。当一个对象被序列化成为 JSON，它被称为一个 JSON 文档 。&lt;/p&gt;

&lt;p&gt;Elastcisearch 是分布式的 文档 存储。它能存储和检索复杂的数据结构–序列化成为JSON文档–以 实时 的方式。 换句话说，一旦一个文档被存储在 Elasticsearch 中，它就是可以被集群中的任意节点检索到。&lt;/p&gt;

&lt;p&gt;在 Elasticsearch 中， 每个字段的所有数据 都是 默认被索引的 。 即每个字段都有为了快速检索设置的专用倒排索引。&lt;/p&gt;

&lt;h2 id=&quot;什么是文档&quot;&gt;什么是文档？&lt;/h2&gt;

&lt;p&gt;我们使用的术语 对象 和 文档 是可以互相替换的。不过，有一个区别： 一个对象仅仅是类似于 hash 、 hashmap 、字典或者关联数组的 JSON 对象，对象中也可以嵌套其他的对象。 对象可能包含了另外一些对象。在 Elasticsearch 中，术语 文档 有着特定的含义。它是指&lt;strong&gt;最顶层&lt;/strong&gt;或者&lt;strong&gt;根对象&lt;/strong&gt;, 这个根对象被&lt;strong&gt;序列化成 JSON&lt;/strong&gt;并存储到 Elasticsearch 中，指定了唯一 ID。&lt;/p&gt;

&lt;h2 id=&quot;文档元数据&quot;&gt;文档元数据&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_index&lt;/code&gt;: 文档存放在那里&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_type&lt;/code&gt;: 文档表示的对象类型&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;: 文档唯一标识&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;_index&quot;&gt;_index&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;索引&lt;/code&gt;应该是因共同的特性被分组到一起的文档集合。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;我们的数据是被存储和索引在 分片 中，而一个索引仅仅是逻辑上的命名空间， 这个命名空间由一个或者多个分片组合在一起。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;_type&quot;&gt;_type&lt;/h3&gt;
&lt;p&gt;数据可能在索引中只是松散的组合在一起。Elasticsearch 公开了一个称为 types （类型）的特性，它允许您在索引中对数据进行逻辑分区。&lt;/p&gt;

&lt;h3 id=&quot;_id&quot;&gt;_id&lt;/h3&gt;
&lt;p&gt;ID 是一个字符串， 当它和 _index 以及 _type 组合就可以唯一确定 Elasticsearch 中的一个文档。&lt;/p&gt;

&lt;h3 id=&quot;索引文档&quot;&gt;索引文档&lt;/h3&gt;
&lt;p&gt;通过使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; API ，文档可以被 索引 —— 存储和使文档可被搜索 。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;index&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;id&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;field&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;value&quot;&lt;/span&gt;,
  ...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;使用自己的-id&quot;&gt;使用自己的 ID&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;Just trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;自增-id&quot;&gt;自增 ID&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My second blog entry&quot;,
  &quot;text&quot;:  &quot;Still trying this out...&quot;,
  &quot;date&quot;:  &quot;2014/01/01&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;取回文档&quot;&gt;取回文档&lt;/h2&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123?pretty&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;返回&lt;/p&gt;
&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_index&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;website&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_type&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;blog&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_id&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;123&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_version&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;found&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;_source&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;My first blog entry&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Just trying this out...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2014/01/01&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;返回文档的一部分&quot;&gt;返回文档的一部分&lt;/h3&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123?_source=title,text&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;检查文档是否存在&quot;&gt;检查文档是否存在&lt;/h2&gt;
&lt;p&gt;如果只想检查一个文档是否存在 –根本不想关心内容–那么用 HEAD 方法来代替 GET 方法。 HEAD 请求没有返回体，只返回一个 HTTP 请求报头：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;200&lt;/code&gt; 存在&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;404&lt;/code&gt; 不存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;更新整个文档&quot;&gt;更新整个文档&lt;/h2&gt;
&lt;p&gt;在 Elasticsearch 中文档是 不可改变 的，不能修改它们。如果想要更新现有的文档，需要 重建索引 或者进行替换。&lt;/p&gt;

&lt;p&gt;使用下面的命令&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;title&quot;: &quot;My first blog entry&quot;,
  &quot;text&quot;:  &quot;I am starting to get the hang of this...&quot;,
  &quot;date&quot;:  &quot;2014/01/02&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们看到文档的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 已经变成 2 ，说明文档更新成功了。但实际上是，将就得&lt;strong&gt;文档&lt;/strong&gt;标记为删除，同时新建了一个&lt;strong&gt;文档&lt;/strong&gt;。
更新一个文档时，Elasticsearch 内部的执行过程大概是&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从旧文档构建 JSON&lt;/li&gt;
  &lt;li&gt;更改该 JSON&lt;/li&gt;
  &lt;li&gt;删除旧文档&lt;/li&gt;
  &lt;li&gt;索引一个新文档&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建新文档&quot;&gt;创建新文档&lt;/h2&gt;
&lt;p&gt;当我们索引一个文档， 怎么确认我们正在创建一个完全新的文档，而不是覆盖现有的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;请记住， &lt;code class=&quot;highlighter-rouge&quot;&gt;_index&lt;/code&gt; 、 &lt;code class=&quot;highlighter-rouge&quot;&gt;_type&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt; 的组合可以唯一标识一个文档。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /website/blog/
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;自增 ID&lt;/p&gt;

&lt;p&gt;第一种方法使用 op_type 查询 -字符串参数：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /website/blog/123?op_type&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;create
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二种方法是在 URL 末端使用 /_create :&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /website/blog/123/_create
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; ... &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果创建新文档的请求成功执行，Elasticsearch 会返回元数据和一个 201 Created 的 HTTP 响应码。&lt;/p&gt;

&lt;p&gt;另一方面，如果具有相同的 _index 、 _type 和 _id 的文档已经存在，Elasticsearch 将会返回 409 Conflict 响应码。&lt;/p&gt;

&lt;h2 id=&quot;删除文档&quot;&gt;删除文档&lt;/h2&gt;
&lt;p&gt;删除文档 的语法和我们所知道的规则相同，只是 使用 DELETE 方法：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; DELETE &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/123&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果找到该文档，Elasticsearch 将要返回一个 200 ok 的 HTTP 响应码，如果文档没有 找到，我们将得到 404 Not Found 的响应码和类似这样的响应体。&lt;/p&gt;

&lt;p&gt;即使文档不存在（ Found 是 false ）， &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 值仍然会增加。&lt;/p&gt;

&lt;h2 id=&quot;处理冲突&quot;&gt;处理冲突&lt;/h2&gt;
&lt;p&gt;当我们使用 index API 更新文档 ，可以一次性读取原始文档，做我们的修改，然后重新索引 整个文档 。 最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。&lt;/p&gt;

&lt;h3 id=&quot;悲观并发控制&quot;&gt;悲观并发控制&lt;/h3&gt;
&lt;p&gt;这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。 一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。&lt;/p&gt;

&lt;h3 id=&quot;乐观并发控制&quot;&gt;乐观并发控制&lt;/h3&gt;
&lt;p&gt;Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。 然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。 例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。&lt;/p&gt;

&lt;h2 id=&quot;乐观并发控制-1&quot;&gt;乐观并发控制&lt;/h2&gt;
&lt;p&gt;Elasticsearch 是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许 顺序是乱的 。 Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。&lt;/p&gt;

&lt;p&gt;Elasticsearch 使用这个 _version 号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。&lt;/p&gt;

&lt;p&gt;所有文档的更新或删除 API，都可以接受 version 参数，这允许你在代码中使用乐观的并发控制，这是一种明智的做法。&lt;/p&gt;

&lt;h3 id=&quot;通过外部系统使用版本控制&quot;&gt;通过外部系统使用版本控制&lt;/h3&gt;
&lt;p&gt;一个常见的设置是使用其它数据库作为主要的数据存储，使用 Elasticsearch 做数据检索， 这意味着主数据库的所有更改发生时都需要被复制到 Elasticsearch ，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。&lt;/p&gt;

&lt;p&gt;如果你的主数据库已经有了版本号 — 或一个能作为版本号的字段值比如 timestamp — 那么你就可以在 Elasticsearch 中通过增加 version_type=external 到查询字符串的方式重用这些相同的版本号， 版本号必须是大于零的整数， 且小于 9.2E+18 — 一个 Java 中 long 类型的正值。&lt;/p&gt;

&lt;p&gt;外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同， Elasticsearch 不是检查当前 _version 和请求中指定的版本号是否相同， 而是检查当前 _version 是否 小于 指定的版本号。 如果请求成功，外部的版本号作为文档的新 _version 进行存储。&lt;/p&gt;

&lt;p&gt;外部版本号不仅在索引和删除请求是可以指定，而且在 创建 新文档时也可以指定。&lt;/p&gt;

&lt;h2 id=&quot;文档的部分更新&quot;&gt;文档的部分更新&lt;/h2&gt;
&lt;p&gt;在 更新整个文档 , 我们已经介绍过 更新一个文档的方法是检索并修改它，然后重新索引整个文档，这的确如此。然而，使用 update API 我们还可以部分更新文档，例如在某个请求时对计数器进行累加。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;doc&quot; : {
      &quot;tags&quot; : [ &quot;testing&quot; ],
      &quot;views&quot;: 0
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;使用脚本部分更新文档那个&quot;&gt;使用脚本部分更新文档那个&lt;/h3&gt;
&lt;p&gt;脚本可以在 update API中用来改变 _source 的字段内容， 它在更新脚本中称为 ctx._source 。 例如，我们可以使用脚本来增加博客文章中 views 的数量：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/blog/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.tags+=new_tag&quot;,
   &quot;params&quot; : {
      &quot;new_tag&quot; : &quot;search&quot;
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新的文档可能尚不存在&quot;&gt;更新的文档可能尚不存在&lt;/h3&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;upsert&lt;/code&gt; 参数&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/website/pageviews/1/_update&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
   &quot;script&quot; : &quot;ctx._source.views+=1&quot;,
   &quot;upsert&quot;: {
       &quot;views&quot;: 1
   }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;更新和冲突&quot;&gt;更新和冲突&lt;/h3&gt;
&lt;p&gt;检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小。 但是它并不能完全消除冲突的可能性。 还是有可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; 设法重新索引之前，来自另一进程的请求修改了文档。&lt;/p&gt;

&lt;p&gt;为了避免数据丢失， &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; API 在 检索 步骤时检索得到文档当前的 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 号，并传递版本号到 重建索引 步骤的 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt; 请求。 如果另一个进程修改了处于检索和重新索引步骤之间的文档，那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;_version&lt;/code&gt; 号将不匹配，更新请求将会失败。&lt;/p&gt;

&lt;p&gt;设置参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;retry_on_conflict&lt;/code&gt; 来在发现冲突时重试更新操作。&lt;/p&gt;

&lt;h2 id=&quot;取回多个文档&quot;&gt;取回多个文档&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;mget API 要求有一个 docs 数组作为参数，每个 元素包含需要检索文档的元数据， 包括 _index 、 _type 和 _id 。&lt;/li&gt;
  &lt;li&gt;如果想检索的数据都在相同的 _index 中（甚至相同的 _type 中），则可以在 URL 中指定默认的 /_index 或者默认的 /_index/_type 。&lt;/li&gt;
  &lt;li&gt;如果所有文档的 _index 和 _type 都是相同的，你可以只传一个 ids 数组，而不是整个 docs 数组。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;即使有某个文档没有找到，上述请求的 HTTP 状态码仍然是 200 。事实上，即使请求 没有 找到任何文档，它的状态码依然是 200 –因为 mget 请求本身已经成功执行。 为了确定某个文档查找是成功或者失败，你需要检查 found 标记。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;代价较小的批量操作&quot;&gt;代价较小的批量操作&lt;/h2&gt;
&lt;p&gt;与 mget 可以使我们一次取回多个文档同样的方式， bulk API 允许在单个步骤中进行多次 create 、 index 、 update 或 delete 请求。 如果你需要索引一个数据流比如日志事件，它可以排队和索引数百或数千批次。&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;每行一定要以换行符(\n)结尾， 包括最后一行。&lt;/li&gt;
  &lt;li&gt;这些行不能包含未转义的换行符，因为他们将会对解析造成干扰。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个完整的 bulk 操作：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/_bulk&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{ &quot;delete&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; }}
{ &quot;create&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; }}
{ &quot;title&quot;:    &quot;My first blog post&quot; }
{ &quot;index&quot;:  { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; }}
{ &quot;title&quot;:    &quot;My second blog post&quot; }
{ &quot;update&quot;: { &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot;, &quot;_retry_on_conflict&quot; : 3} }
{ &quot;doc&quot; : {&quot;title&quot; : &quot;My updated blog post&quot;} }
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;每个子请求都是独立执行，因此某个子请求的失败不会对其他子请求的成功与否造成影响。&lt;/strong&gt;这也意味着 bulk 请求不是原子的： 不能用它来实现事务控制。每个请求是单独处理的，因此一个请求的成功或失败不会影响其他的请求。&lt;/p&gt;

&lt;h3 id=&quot;多大是太大了&quot;&gt;多大是太大了？&lt;/h3&gt;
&lt;p&gt;整个批量请求都需要由接收到请求的节点加载到内存中，因此该请求越大，其他请求所能获得的内存就越少。&lt;/p&gt;

&lt;p&gt;通过批量索引典型文档，并不断增加批量大小进行尝试。 当性能开始下降，那么你的批量大小就太大了。一个好的办法是开始时将 1,000 到 5,000 个文档作为一个批次, 如果你的文档非常大，那么就减少批量的文档个数。&lt;/p&gt;

&lt;p&gt;密切关注你的批量请求的物理大小往往非常有用，一千个 1KB 的文档是完全不同于一千个 1MB 文档所占的物理大小。 一个好的批量大小在开始处理后所占用的物理大小约为 5-15 MB。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">数据输入和输出</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 2</title><link href="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 2" /><published>2018-05-07T18:16:46+08:00</published><updated>2018-05-07T18:16:46+08:00</updated><id>http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2</id><content type="html" xml:base="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-2.html">&lt;p&gt;集群内的原理&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;ElastiSearch天生就是 分布式的 ，它知道如何通过管理多节点来提高扩容性和可用性。&lt;/p&gt;

&lt;p&gt;一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。&lt;/p&gt;

&lt;h2 id=&quot;空集群&quot;&gt;空集群&lt;/h2&gt;

&lt;p&gt;一个运行中的 Elasticsearch 实例称为一个 节点，而集群是由一个或者多个拥有相同 &lt;code class=&quot;highlighter-rouge&quot;&gt;cluster.name&lt;/code&gt; 配置的节点组成， 它们共同承担数据和负载的压力。当一个节点被选举成为 主 节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。主节点并不需要涉及到&lt;strong&gt;文档级别&lt;/strong&gt;的变更和搜索等操作。&lt;/p&gt;

&lt;p&gt;可以将请求发送到 集群中的任何节点 ，包括主节点。&lt;/p&gt;

&lt;h2 id=&quot;集群健康&quot;&gt;集群健康&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;集群健康&lt;/em&gt; ， 它在 status 字段中展示为 green 、 yellow 或者 red&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;green&lt;/code&gt;: 所有的主分片和副本分片都正常运行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;yellow&lt;/code&gt;: 所有的主分片都正常运行，但不是所有的副本分片都正常运行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;red&lt;/code&gt;: 有主分片没能正常运行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;添加索引&quot;&gt;添加索引&lt;/h2&gt;
&lt;p&gt;往 Elasticsearch 添加数据时需要用到 索引 —— 保存相关数据的地方。 索引实际上是指向一个或者多个物理 分片 的 逻辑命名空间 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个 分片 是一个底层的 工作单元 ，它仅保存了 全部数据中的一部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Elasticsearch 是利用分片将数据分发到集群内各处的。分片是数据的容器，文档保存在分片内，分片又被分配到集群内的各个节点里。 当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里。&lt;/p&gt;

&lt;p&gt;一个分片可以是 主 分片或者 副本 分片。 索引内任意一个文档都归属于一个主分片，所以主分片的数目决定着索引能够保存的最大数据量。一个副本分片只是一个主分片的拷贝。&lt;/p&gt;

&lt;p&gt;在索引建立的时候就已经确定了主分片数，但是副本分片数可以随时修改。&lt;/p&gt;

&lt;h2 id=&quot;水平扩容&quot;&gt;水平扩容&lt;/h2&gt;
&lt;p&gt;分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有6个分片（3个主分片和3个副本分片）的索引可以最大扩容到6个节点，每个节点上存在一个分片，并且每个分片拥有所在节点的全部资源。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主分片的数目在索引创建时 就已经确定了下来。实际上，这个数目定义了这个索引能够 存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;应对故障&quot;&gt;应对故障&lt;/h2&gt;
&lt;p&gt;我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。
所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">集群内的原理</summary></entry><entry><title type="html">Elasticsearch - The Definitive Guide - Chapter 1</title><link href="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1.html" rel="alternate" type="text/html" title="Elasticsearch - The Definitive Guide - Chapter 1" /><published>2018-05-07T16:50:10+08:00</published><updated>2018-05-07T16:50:10+08:00</updated><id>http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1</id><content type="html" xml:base="http://www.teslalee.com/2018/05/07/Elasticsearch-The-Definitive-Guide-Chapter-1.html">&lt;p&gt;你知道的，为了搜索…
&lt;!--more--&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：&lt;/p&gt;

  &lt;p&gt;一个分布式的实时文档存储，每个字段 可以被索引与搜索
一个分布式实时分析搜索引擎
能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;与-elasticsearch-交互&quot;&gt;与 Elasticsearch 交互&lt;/h2&gt;

&lt;h3 id=&quot;java-客户端&quot;&gt;JAVA 客户端&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;节点客户端（Node client）
    &lt;ul&gt;
      &lt;li&gt;节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;传输客户端（Transport client）
    &lt;ul&gt;
      &lt;li&gt;轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。&lt;/p&gt;

&lt;h3 id=&quot;rest-api&quot;&gt;REST API&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt;&amp;lt;VERB&amp;gt; &lt;span class=&quot;s1&quot;&gt;'&amp;lt;PROTOCOL&amp;gt;://&amp;lt;HOST&amp;gt;:&amp;lt;PORT&amp;gt;/&amp;lt;PATH&amp;gt;?&amp;lt;QUERY_STRING&amp;gt;'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&amp;lt;BODY&amp;gt;'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VERB&lt;/code&gt;: 适当的 HTTP 方法 或 谓词 : &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;PUT&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PROTOCOL&lt;/code&gt;: http 或者 https&lt;code class=&quot;highlighter-rouge&quot;&gt;（如果你在 Elasticsearch 前面有一个 &lt;/code&gt;https 代理）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HOST&lt;/code&gt;: Elasticsearch 集群中任意节点的主机名，或者用 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost&lt;/code&gt; 代表本地机器上的节点&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PORT&lt;/code&gt;: 运行 Elasticsearch HTTP 服务的端口号，默认是 9200&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;: API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;_cluster/stats&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_nodes/stats/jvm&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QUERY_STRING&lt;/code&gt;:&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BODY&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;面向文档&quot;&gt;面向文档&lt;/h2&gt;
&lt;p&gt;Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。&lt;/p&gt;

&lt;h2 id=&quot;demo-数据&quot;&gt;DEMO 数据&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;支持包含多值标签、数值、以及全文本的数据&lt;/li&gt;
  &lt;li&gt;检索任一雇员的完整信息&lt;/li&gt;
  &lt;li&gt;允许结构化搜索，比如查询 30 岁以上的员工&lt;/li&gt;
  &lt;li&gt;允许简单的全文搜索以及较复杂的短语搜索&lt;/li&gt;
  &lt;li&gt;支持在匹配文档内容中高亮显示搜索片段&lt;/li&gt;
  &lt;li&gt;支持基于数据创建和管理分析仪表盘&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;索引存储雇员文档&quot;&gt;索引（存储）雇员文档&lt;/h2&gt;
&lt;p&gt;这将会以 雇员文档 的形式存储：一个文档代表一个雇员。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你也许已经注意到 索引 这个词在 Elasticsearch 语境中包含多重意思， 所以有必要做一点儿说明：
索引（名词）：&lt;/p&gt;

  &lt;p&gt;如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。&lt;/p&gt;

  &lt;p&gt;索引（动词）：&lt;/p&gt;

  &lt;p&gt;索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。&lt;/p&gt;

  &lt;p&gt;倒排索引：
关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。&lt;/p&gt;

  &lt;p&gt;默认的，一个文档中的每一个属性都是 被索引 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。我们将在 倒排索引 讨论倒排索引的更多细节。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; PUT &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/1&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;first_name&quot; : &quot;John&quot;,
    &quot;last_name&quot; :  &quot;Smith&quot;,
    &quot;age&quot; :        25,
    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,
    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;轻量搜索&quot;&gt;轻量搜索&lt;/h2&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search?q=last_name:Smith&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;查询表达式-query-dsl&quot;&gt;查询表达式 Query DSL&lt;/h2&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;last_name&quot; : &quot;Smith&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;更复杂的搜索&quot;&gt;更复杂的搜索&lt;/h2&gt;
&lt;p&gt;同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;bool&quot;: {
            &quot;must&quot;: {
                &quot;match&quot; : {
                    &quot;last_name&quot; : &quot;smith&quot;
                }
            },
            &quot;filter&quot;: {
                &quot;range&quot; : {
                    &quot;age&quot; : { &quot;gt&quot; : 30 }
                }
            }
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;全文搜索&quot;&gt;全文搜索&lt;/h2&gt;
&lt;p&gt;Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;短语搜索&quot;&gt;短语搜索&lt;/h2&gt;
&lt;p&gt;找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者短语 。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;高亮搜索&quot;&gt;高亮搜索&lt;/h2&gt;
&lt;p&gt;许多应用都倾向于在每个搜索结果中 高亮 部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;about&quot; : &quot;rock climbing&quot;
        }
    },
    &quot;highlight&quot;: {
        &quot;fields&quot; : {
            &quot;about&quot; : {}
        }
    }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; GET &lt;span class=&quot;s2&quot;&gt;&quot;localhost:9200/megacorp/employee/_search&quot;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'
{
  &quot;aggs&quot;: {
    &quot;all_interests&quot;: {
      &quot;terms&quot;: { &quot;field&quot;: &quot;interests&quot; }
    }
  }
}
'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;分布式特性&quot;&gt;分布式特性&lt;/h2&gt;
&lt;p&gt;Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中&lt;/li&gt;
  &lt;li&gt;按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡&lt;/li&gt;
  &lt;li&gt;复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失&lt;/li&gt;
  &lt;li&gt;将集群中任一节点的请求路由到存有相关数据的节点&lt;/li&gt;
  &lt;li&gt;集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tesla Lee</name></author><summary type="html">你知道的，为了搜索…</summary></entry><entry><title type="html">九州</title><link href="http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html" rel="alternate" type="text/html" title="九州" /><published>2018-05-07T00:00:00+08:00</published><updated>2018-05-07T00:00:00+08:00</updated><id>http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents</id><content type="html" xml:base="http://www.teslalee.com/%E4%B9%9D%E5%B7%9E/2018/05/07/nine-continents.html">&lt;p&gt;九州设定
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;设定&quot;&gt;设定&lt;/h2&gt;

&lt;p&gt;最初，世界只有混沌，无数的基本粒子，漫无边际地飘荡在混沌中，没有方向，没有边界，没有时间。&lt;/p&gt;

&lt;p&gt;粒子间凝聚和排斥的力量使得混沌中产生了运动。当运动的趋势逐渐发展后，混沌被某一个偶然的搅动打破了。这个搅动只是那些粒子偶然出现的有序排列，奇妙的图纹隐现在混沌中，有序的排列组合第一次出现在混沌中。这就是第一个意识。&lt;/p&gt;

&lt;p&gt;意识的特性将可延续的、可积累的认知阶段当做是真实的，那一段时间中意识的活动称为“醒”；将断断续续的、不积累的那一段当做是虚幻的，那一段时间中的意识活动称为“梦”。第一个意识进入了断续的梦境。梦境中的意识不断地加强自己，对抗重新归于混沌的凝聚力量。当这个意识强大到足以辨别自己的时候，它忽然从梦幻里醒来，开始认识所处的世界。这个意识发现周围的世界竟然不是它的梦而仅仅是混沌。有序的梦境与它所存在的混沌的世界存在强烈的反差，使得这个意识产生了创造的愿望。&lt;/p&gt;

&lt;p&gt;在世界初始的那一段时间里，第一个意识不断的加强自己，对抗重新归于混沌的凝聚力量。&lt;/p&gt;

&lt;p&gt;这个意识被称作世界的第一个主神“墟”。而混沌本身则产生了对应的概念上的主神“荒”。荒代表无所不在的强大凝聚力，可是他没有意识。&lt;/p&gt;

&lt;p&gt;墟是精神的主神，荒是物质的主神。&lt;/p&gt;

&lt;p&gt;荒想要重新回复到混沌状态，而墟不允许荒破坏他的创造，于是他奋力撞击在混沌的中心，从而导致整个混沌产生了空前绝后的大爆炸，荒的一部分身体被震碎为尘埃，他的主体却被凝聚力牢牢地抓住，形成了一个被称作大地的球体。而墟在撞击中完全粉碎，他精神的碎片化成无数星辰瞬间飞出了混沌，却被凝聚的力量抓在环绕在球体的周围。星辰的精神也成为第一批有独立意识的次神。&lt;/p&gt;

&lt;p&gt;次神是墟的碎片，他们微弱地回忆起主神墟的意志是阻止世界重新凝聚为混沌。可是荒所具有的强大凝聚力依然在吸引周围的物质碎片。这一力量最终将会导致星辰诸神被吸聚回主神荒，回到混沌状态。&lt;/p&gt;

&lt;p&gt;惊恐的诸神于是在荒的身体上施展一个法术，他们用荒的碎片中的精华物质制造了捆绑束缚荒的封印，布满主神荒的身体，以阻止荒的凝聚，并且不惜把自己的一部分精神加入这些封印图纹，使之具有意识。这就是生命的诞生。&lt;/p&gt;

&lt;p&gt;这些生物中，得到了较多精神力的，逐渐发展成为具有文明的智慧种族。&lt;/p&gt;

&lt;p&gt;诸神明白只有精神的力量才能阻止荒的凝聚，因此他们把这些生物放置在大地的四方，并赋予它们自由意识所具有的一切矛盾特性：对秩序的向往和争战的本能。诸神希望各种冲突力量阻止这些种族走到一起，从而荒的碎片不会彻底融合，也就不会有新的混沌。&lt;/p&gt;

&lt;p&gt;任何精神体都是矛盾的，墟希望通过最终战争实现一个完全由他意识建立的有序世界，而荒则默默的行使力量把世界重新凝聚成一个无序的混沌整体。当今世界只是墟依照无尽梦幻中的体验而创造的模型，墟从当今的世界中汲取创造的经验，希望战胜荒后建立完美的世界。而荒的唯一目的就是毁灭世界归于混沌。&lt;/p&gt;

&lt;p&gt;精神和物质，混乱和秩序，构成了这个世界的终级冲突，并成为一切生物意识中的烙印。&lt;/p&gt;

&lt;h2 id=&quot;地理&quot;&gt;地理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/九州地图.jpg&quot; alt=&quot;九州地图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;九州的已知世界由三块大陆组成，按照上古的传说划分为九个州，这正是九州名称的来源。&lt;/p&gt;

&lt;h3 id=&quot;北陆&quot;&gt;北陆&lt;/h3&gt;

&lt;h4 id=&quot;殇州&quot;&gt;殇州&lt;/h4&gt;
&lt;p&gt;殇州位于北陆西部，二面临海，向北是茫茫雪山冰原的寒冷大陆。东部与翰州以火雷原为界。面积约十万拓。殇州主要分为三大地形带：北部为殇州高原，东起蛮古山脉，西至天池山脉，其中蛮古山脉为北陆最高部分，平均海拔超过1万尺。中部和东部地区地势趋于平缓，长期的剥蚀作用形成了数片广阔而起伏平缓的平原，其间分布有一些小山和丘陵。西南部地区是一条火山带，统称为冰炎地海，分布有数十座较大的火山和更多小型或休眠的火山。更西面在浩瀚洋中分布有火山岛群。
这是一片冰与火的大陆，相应的气候分布也多变。殇州高原气候寒冷，夏季普遍气温低，降水丰沛，无论冬季还是夏季，都是既能下雨，也能下雪。该地区不适于乔木生长，灌木丛和苔原是殇州高原的常见植被。西南部地热资源丰富，可见到木本植物组成的小林，在背风的地方或热泉附近分布着杂草草甸。中东部的平原区气候状况比瀚州平原略复杂，以森林植被为主，针叶林的分布最为广泛，阔叶树的种类较少，森林草原和草原分布在与瀚州的交界处。&lt;/p&gt;

&lt;h4 id=&quot;瀚州&quot;&gt;瀚州&lt;/h4&gt;
&lt;p&gt;瀚州位于北陆中部，东连宁州，西接殇州，总面积约十五万拓。西南是涣海，下端指向滁潦海。西部受到殇州高原地形带的影响，平均海拔较高。中部地区地势平坦，一马平川。东部由极宽的天拓大江与中州隔开。西端由霍零江与云州隔开。 瀚州大部分地区降水量不足，森林不能自然生长，以草原为主，自然植被主要是丛生禾草，并混生有多种双子叶杂草。东部彤云山地区则由森林草原逐渐向混交林区过渡。溟朦海位于翰州中部草原，是北陆最大的湖泊，周围形成形成大片的绿州沃野。&lt;/p&gt;

&lt;h4 id=&quot;宁州&quot;&gt;宁州&lt;/h4&gt;
&lt;p&gt;宁州位于北陆最东部，三面临海，面积约十一万拓，其东南部为丘陵地带，分布森林和森林草原，乌鬼山横越其北，三昧河自此向南入海口时，变成了三条纵横交错的宽阔河道，因为土质和藻类的不同，分别呈青绿，淡紫和绛红三种颜色。宁州西部多为荒漠戈壁，众多破碎的丘陵一路连向虎皮山脉。极西端与瀚州间隔勾弋山，勾弋山高万仞，因为山峰终年积雪，云开雾散之际银光闪闪，又被称为”月亮山脉”，其主峰为北陆最高山。宁州北部多为厚厚的冰川层覆盖，这块巨大冰原的面积几乎相当于四分之一的宁州，主要植被是在短暂的夏季中长满的苔藓和草本植物。&lt;/p&gt;

&lt;h3 id=&quot;东陆&quot;&gt;东陆&lt;/h3&gt;
&lt;h4 id=&quot;澜州&quot;&gt;澜州&lt;/h4&gt;
&lt;p&gt;澜州位于东陆东块，东部临海，西接中州，南部与越州为邻。面积约十五万拓。整个澜州形势如弓，销金河如弦横跨南北，东陆最高峰的擎梁山就架在弓脊上。澜州平均海拔超过3000尺，是东陆平均海拔最高的地区，地堑性的中央低地把澜州分割为东北和西南两部。东北的夜北高原是一个地垒性地块，西南与越州交界处由于降水较多，是大片的沼泽地和森林。 整个夜北高原土地凉薄，兼之气候不利，一年中冬季长达5个月，除了寒地的针叶林生长颇速，农作物生长却非常不利，重要的粮食产区仅在西南小部分地域。沼泽地和森林带人迹稀少，树木林冠稠密，层次很多，且多藤本和附生植物。&lt;/p&gt;

&lt;h4 id=&quot;中州&quot;&gt;中州&lt;/h4&gt;
&lt;p&gt;中州位于东陆的北块，南接宛州，东靠澜州。面积约十五万拓，是东陆第一大州。中州地形以山脉和平原为主，从澜州夜北高原延伸下东西走向的两条隆起带和二条沉降带，隆起带主要为山地地形，沉降带则形成为盆地和平原。 中州的风向、降水均随季节而有明显的更替，自然植被以森林为主，既有冷湿性森林、森林草原景观，又有半湿润半干旱夏绿林、森林草原景观，混有落叶阔叶林。&lt;/p&gt;

&lt;h4 id=&quot;宛州&quot;&gt;宛州&lt;/h4&gt;
&lt;p&gt;宛州位于东陆西块，北与中州交界，东与越州相邻。面积约十二万拓。宛州地形受到建水与西江以及诸多小河流的切割，大部分呈丘陵状，只有与中州交接的平原才是宛州的平坦部分。宛州东部受到雷眼山脉和北邙山脉影响，地势较复杂，雁返湖是宛州大部分河流的发源地。 宛州气候温和的，冬不太冷，夏不太热，降水适中，大多数地区没有干旱的感觉。这种气候条件适宜于木本植物的生长，阔叶林是本区的地带性植被。&lt;/p&gt;

&lt;h4 id=&quot;越州&quot;&gt;越州&lt;/h4&gt;
&lt;p&gt;越州位于东陆南块，面积约十二万拓，在东陆四州中列于第三。越州中部和西部地区以丘陵和低山为主，雷眼、北邙山脉诸多延伸山脉呈绵延不断的岭脊，主要是块状山，峰峦耸立，山坡陡峭，岩石裸露，地形十分崎岖，山岭间错纵地分布着面积不大的山谷和盆地，盆地中水源丰富，东部和北部沿岸为海岸平原，沿海沙洲、潟湖较多，东南部还有珊瑚礁海岸。 越州的基本植被是硬叶常绿群落，不限于分布在沿海和平原地区，并沿河谷深入到山地内部，由于越州是人口最稀少的地区，全境森林覆盖率达到60％至70％。&lt;/p&gt;

&lt;h3 id=&quot;西陆&quot;&gt;西陆&lt;/h3&gt;
&lt;h4 id=&quot;云州&quot;&gt;云州&lt;/h4&gt;
&lt;p&gt;面积均约十二万拓，与雷州以中部被称为沉沙海的海湾为界。由于云州西部为高耸的赤华山脉，东部有丘陵群，地势较高，天高云远，所以中部有连片沙漠，与山谷交错着。&lt;/p&gt;

&lt;h3 id=&quot;雷州&quot;&gt;雷州&lt;/h3&gt;
&lt;p&gt;面积约十三万拓。与云州截然不同，气候调和，植物茂盛多样，两边临海，气候多雨潮湿，森林茂密。&lt;/p&gt;

&lt;h2 id=&quot;种族&quot;&gt;种族&lt;/h2&gt;

&lt;h3 id=&quot;人族&quot;&gt;人族&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;人是最平均也最复杂的种族，他们没有关夸父的高大，河络的技术，羽族的轻灵，鲛人的善水，魅的魔力。但他们有最庞大的人口和最完善的制度文明。人族有北陆，东陆，西陆三大文明带。北陆人为游牧文明，东陆人为农业文明，西陆的城邦文明则因为瘟疫而淹没在沙漠密林之后，成为探险发现的天堂。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;羽族&quot;&gt;羽族&lt;/h3&gt;
&lt;h3 id=&quot;夸父&quot;&gt;夸父&lt;/h3&gt;
&lt;h3 id=&quot;河络&quot;&gt;河络&lt;/h3&gt;
&lt;h3 id=&quot;鲛人&quot;&gt;鲛人&lt;/h3&gt;
&lt;h3 id=&quot;魅族&quot;&gt;魅族&lt;/h3&gt;</content><author><name>Tesla Lee</name></author><summary type="html">九州设定</summary></entry><entry><title type="html">Query DSL of Elasticsearch</title><link href="http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html" rel="alternate" type="text/html" title="Query DSL of Elasticsearch" /><published>2018-05-04T00:00:00+08:00</published><updated>2018-05-04T00:00:00+08:00</updated><id>http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch</id><content type="html" xml:base="http://www.teslalee.com/elasticsearch/2018/05/04/query-dsl-of-elasticsearch.html">&lt;p&gt;Elasticsearch 查询 DSL 基础知识&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;query-dsl&quot;&gt;Query DSL&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Leaf query clauses（子查询）：在一个特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Field&lt;/code&gt; 查询特定的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 查询。&lt;/li&gt;
  &lt;li&gt;Compound query clauses（组合查询）：将子查询或组合查询再组合起来，例如，使用逻辑（&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;dis_max&lt;/code&gt;)，或者改变查询的行为（&lt;code class=&quot;highlighter-rouge&quot;&gt;not&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Query clauses behave differently depending on whether they are used in query context or filter context.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;query-and-filter-context&quot;&gt;Query and filter context&lt;/h2&gt;

&lt;p&gt;The behaviour of a query clause depends on whether it is used in query context or in filter context:&lt;/p&gt;

&lt;h3 id=&quot;query-context&quot;&gt;Query context&lt;/h3&gt;
&lt;p&gt;A query clause used in query context answers the question “&lt;strong&gt;How well does this document match this query clause?&lt;/strong&gt;”.The query clause also calculates a _score representing how well the document matches, relative to other documents.&lt;/p&gt;

&lt;h3 id=&quot;filter-context&quot;&gt;Filter Context&lt;/h3&gt;
&lt;p&gt;In filter context, a query clause answers the question “&lt;strong&gt;Does this document match this query clause?&lt;/strong&gt;”&lt;/p&gt;

&lt;p&gt;Frequently used filters will be cached automatically by Elasticsearch, to speed up performance.&lt;/p&gt;

&lt;p&gt;Filter context is in effect whenever a query clause is passed to a filter parameter, such as the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;must_not&lt;/code&gt; parameters in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; query, the filter parameter in the &lt;code class=&quot;highlighter-rouge&quot;&gt;constant_score&lt;/code&gt; query, or the &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; aggregation.&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_search&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;query&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;bool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;must&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Search&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Elasticsearch&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;filter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;term&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;published&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;range&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;publish_date&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gte&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-01-01&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query&lt;/code&gt; 指 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 和两个 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;query context&lt;/code&gt; 使用，来评价每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt; 的评分&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt; 表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;term&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt; 语句是在 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter context&lt;/code&gt; 中使用，他们用来筛选 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;问题：&lt;code class=&quot;highlighter-rouge&quot;&gt;Filter context&lt;/code&gt; 是在计算 score 前执行还是在计算 score 后执行？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;match-all-query&quot;&gt;Match all query&lt;/h2&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;match_all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;匹配所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，并且给它们一个默认分数 &lt;code class=&quot;highlighter-rouge&quot;&gt;1.0&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;full-text-queries&quot;&gt;Full text queries&lt;/h2&gt;
&lt;p&gt;The high-level full text queries are usually used for running full text queries on full text fields like the body of an email.They understand how the field being queried is analyzed and will apply each field’s analyzer (or search_analyzer) to the query string before executing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; query: 单个基础全文搜索，包括模糊、短语或近似查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi_match&lt;/code&gt; query: 多个字段的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;common_terms&lt;/code&gt; query: 更特殊的查询，用于处理一些不常用的词&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;query_string&lt;/code&gt; query: Supports the compact Lucene query string syntax, allowing you to specify AND&lt;/td&gt;
          &lt;td&gt;OR&lt;/td&gt;
          &lt;td&gt;NOT conditions and multi-field search within a single query string. For expert users only.&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple_query_string&lt;/code&gt;: A simpler, more robust version of the query_string syntax suitable for exposing directly to users.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;match-query&quot;&gt;Match Query&lt;/h3&gt;

&lt;h4 id=&quot;boolean&quot;&gt;boolean&lt;/h4&gt;

&lt;p&gt;默认的 &lt;code class=&quot;highlighter-rouge&quot;&gt;match&lt;/code&gt; 查询是 &lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">Elasticsearch 查询 DSL 基础知识</summary></entry></feed>