<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-01T22:18:11+08:00</updated><id>http://localhost:4000/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">Chapter 2 - Lexical Analysis</title><link href="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html" rel="alternate" type="text/html" title="Chapter 2 - Lexical Analysis" /><published>2018-04-26T00:00:00+08:00</published><updated>2018-04-26T00:00:00+08:00</updated><id>http://localhost:4000/compiler/2018/04/26/lexical-analysis</id><content type="html" xml:base="http://localhost:4000/compiler/2018/04/26/lexical-analysis.html">&lt;p&gt;『Modern Compiler Implementation in C』词法分析部分笔记和总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;lex-i-cal&lt;/strong&gt; : of or relating to words or the vocabulary of a language as distinguished from its grammar and construction&lt;/p&gt;

  &lt;p&gt;— Webster’s Dictionary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要将程序从一种语言翻译到另一种语言，编译器要先将程序处理成&lt;strong&gt;片段&lt;/strong&gt;，并理解其&lt;strong&gt;结构&lt;/strong&gt;和&lt;strong&gt;意义&lt;/strong&gt;，然后将片段重新再组合。编译器前端负责&lt;strong&gt;分析&lt;/strong&gt;，而后端负责&lt;strong&gt;整合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;分析工作主要:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析（Lexical analysis）：将输入识别成词，既（Token）。&lt;/li&gt;
  &lt;li&gt;语法分析（Syntax analysis）：分析程序的机构&lt;/li&gt;
  &lt;li&gt;语义分析（Semantic analysis）：计算出程序的意义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;词法分析器输入字符流，输出词，关键字，符号等。&lt;/p&gt;

&lt;h2 id=&quot;lexical-tokens&quot;&gt;LEXICAL TOKENS&lt;/h2&gt;
&lt;p&gt;Lexical token 是一个字符序列，它是一门语言的最小语法元素。一门编程语言的 token 类型，是一个有限集合。&lt;/p&gt;

&lt;h3 id=&quot;例如&quot;&gt;例如：&lt;/h3&gt;

&lt;p&gt;Token 类型 例子&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ID foo n14, last&lt;/li&gt;
  &lt;li&gt;NUM 74 0 00 082&lt;/li&gt;
  &lt;li&gt;REAL 66.1 .5 10. 1e66 5.5e-10&lt;/li&gt;
  &lt;li&gt;IF if&lt;/li&gt;
  &lt;li&gt;COMMA ,&lt;/li&gt;
  &lt;li&gt;NOTEQ !=&lt;/li&gt;
  &lt;li&gt;LPAREN (&lt;/li&gt;
  &lt;li&gt;RPAREN )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像 if，void，这样的符号，我们称之为&lt;strong&gt;保留字&lt;/strong&gt;，在大部分语言里，保留字不能作为 ID 来使用。&lt;/p&gt;

&lt;p&gt;Lexical token 是最基本的有意义的语法元素。在一般语言中我们都会遇到什么 &lt;strong&gt;ID&lt;/strong&gt;，&lt;strong&gt;IF&lt;/strong&gt;，&lt;strong&gt;CONDITION&lt;/strong&gt; 等等，这些都是语法元素。每一种词法元素都有起描述的规则，用来分析时确定改词法元素。&lt;/p&gt;

&lt;p&gt;我们肯定可以使用自然语言来描述词法规则。但一般情况下，我们使用正则表达式来描述词法规则，同时使用 &lt;strong&gt;DFA&lt;/strong&gt; 来实现词法分析器。&lt;/p&gt;

&lt;p&gt;下面会先复习一些正则的基本知识。&lt;/p&gt;

&lt;h2 id=&quot;regular-expression&quot;&gt;REGULAR EXPRESSION&lt;/h2&gt;
&lt;p&gt;先简单复习一下正则表达式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Symbol（符号）&lt;/li&gt;
  &lt;li&gt;Alternation（选择）&lt;/li&gt;
  &lt;li&gt;Concatenation（连续，连接）&lt;/li&gt;
  &lt;li&gt;Epsilon（空）&lt;/li&gt;
  &lt;li&gt;Repetition（重复）：重复一次，重复多次，至少重复一次&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Kleene closure: Given a regular expression M, its Kleene closure is $M^*$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;写法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$a$ : 普通字符&lt;/li&gt;
  &lt;li&gt;$\epsilon$ : 空字符串&lt;/li&gt;
  &lt;li&gt;$M \mid N$ : 选择 M 或 N&lt;/li&gt;
  &lt;li&gt;$M \bullet N$ (MN) : 连接&lt;/li&gt;
  &lt;li&gt;$M^\ast$ : 重复出现零次或多次&lt;/li&gt;
  &lt;li&gt;$M^+$ : 重复出现一次或多次&lt;/li&gt;
  &lt;li&gt;$M?$ : 出现一次或者不出现&lt;/li&gt;
  &lt;li&gt;$[a-zA-Z]$: 再大小写字母中选择&lt;/li&gt;
  &lt;li&gt;$\bullet$ : 表示任意字符&lt;/li&gt;
  &lt;li&gt;“$a.+^\ast$” : 精确匹配完成字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在引入正则表达式后，我们就可以来描述词法规则了&lt;/p&gt;

&lt;p&gt;加入有一下词法规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;IF: $if$&lt;/li&gt;
  &lt;li&gt;ID: $[a-z][a-z0-9]^\ast $&lt;/li&gt;
  &lt;li&gt;NUM: $[0-9]^+ $&lt;/li&gt;
  &lt;li&gt;REAL: $([0-9]^+”.”[0-9]^\ast) \mid ([0-9]^\ast”.”[0-9]^+)$&lt;/li&gt;
  &lt;li&gt;do nothing: $(“–“[a–z]^\ast”\n”) \mid (“\space” \mid “\n” \mid “\t”)^\ast$&lt;/li&gt;
  &lt;li&gt;error: $.$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关键字 &lt;strong&gt;if&lt;/strong&gt;，标识符 &lt;strong&gt;ID&lt;/strong&gt;，数字 &lt;strong&gt;NUM&lt;/strong&gt;，以及实数 &lt;strong&gt;REAL&lt;/strong&gt;，还定义了注释 『–』开头的单行注释。&lt;/p&gt;

&lt;p&gt;但，写到这里，我们很快会注意到一个问题：&lt;strong&gt;IF&lt;/strong&gt; 和 &lt;strong&gt;ID&lt;/strong&gt; 这两个规则是有交集的。在没有假如更多规则的情况下，我们如何去识别 &lt;em&gt;if&lt;/em&gt; 到底是 &lt;strong&gt;ID token&lt;/strong&gt; 还是 &lt;strong&gt;IF token&lt;/strong&gt;？再比如 &lt;em&gt;if8&lt;/em&gt; 是先匹配 &lt;strong&gt;IF&lt;/strong&gt; 规则还是先匹配 &lt;strong&gt;ID&lt;/strong&gt; 规则？&lt;/p&gt;

&lt;p&gt;下面引入两种常用的去歧义规则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Longest match&lt;/strong&gt;：也就是最长匹配原则，规则所能匹配的最长子串作为下一个输出的 token。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Rule priority&lt;/strong&gt;：规则优先级原则，对于一个最长子串，第一个能够匹配的规则所表示 token 作为输。这也就意味着，匹配的顺序是有意义且重要的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;好了，到这里可以先简单的做一下总结。一门语言，有其最基本的语法元素，这里是 Lexical token。我们需要描述每一种 token 的规则，当然可以使用自然语言，但要让 Lexer 理解，必须要使用一种能实现成程序的方式。
于是我们引入了 Regular Expression 来描述词法规则。同时付加了两条消除歧义的规则，&lt;strong&gt;最长匹配&lt;/strong&gt;和&lt;strong&gt;匹配优先级&lt;/strong&gt;
那么，到这里我有一个疑问？是不是使用 Regular Expression 来描述，就已经可以实现一个 token 匹配，来生成 Lexical token 了？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finite-automata&quot;&gt;FINITE AUTOMATA&lt;/h2&gt;

&lt;p&gt;在前面一段里，我最后有一个问题：因为 Regular Expression 是大多数语言都有的，要实现 token 匹配，是不是就可以使用 Regular Expression 就足够了？&lt;/p&gt;

&lt;p&gt;我的个人感觉是，如果想要这么做是没有问题的，一定可以实现 token 匹配的功能。但是 Regular Expression 实现 lexing 和 parsing 有其问题，这里我正好在网上搜到了 Rob Pike 一篇文章 &lt;a href=&quot;https://commandcenter.blogspot.com/2011/08/regular-expressions-in-lexing-and.html&quot;&gt;Regular expression in lexing and parsing&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我这里摘取他的观点放在这里。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are hard to write, hard to write well, and can be expensive relative to other technologies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A regular expression library is a big thing. Using one to parse identifiers is like using a Mack truck to go to the store for milk. And when we want to adjust our lexer to admit other character types, such as Unicode identifiers, and handle normalization, and so on, the hand-written loop can cope easily but the regexp approach will break down.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Using regular expressions to explore the parse state to find the way forward is expensive, overkill, and error-prone.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Regular expressions are, in my experience, widely misunderstood and abused.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我个人对于 Regular Expression 并没有完全精通。但对于他上面提到的几点，基本都赞同。&lt;/p&gt;

&lt;p&gt;由此，我们就在这里引入了新的方式 Finite Automata，有限自动机。&lt;/p&gt;

&lt;h3 id=&quot;什么是有限自动机&quot;&gt;什么是有限自动机？&lt;/h3&gt;

&lt;p&gt;有限自动机是一种状态机，它通过状态转化来实现接受或者拒绝特定字符串的功能。&lt;/p&gt;

&lt;p&gt;这里就摘取维基百科对于状态机的定义&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Automata theory.svg
About this image
Classes of automata
(Clicking on each layer will take you to an article on that subject)
A finite-state machine (FSM) or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine, is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some external inputs; the change from one state to another is called a transition. An FSM is defined by a list of its states, its initial state, and the conditions for each transition. Finite state machines are of two types - deterministic finite state machines and non-deterministic finite state machines.[1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The behavior of state machines can be observed in many devices in modern society that perform a predetermined sequence of actions depending on a sequence of events with which they are presented. Examples are vending machines, which dispense products when the proper combination of coins is deposited, elevators, whose sequence of stops is determined by the floors requested by riders, traffic lights, which change sequence when cars are waiting, and combination locks, which require the input of combination numbers in the proper order.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The finite state machine has less computational power than some other models of computation such as the Turing machine.[2] The computational power distinction means there are computational tasks that a Turing machine can do but a FSM cannot. This is because a FSM’s memory is limited by the number of states it has. FSMs are studied in the more general field of automata theory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，现在引入了有限自动机这个概念。
有限自动机可以很方便的是现成程序。
有限自动机由：&lt;strong&gt;状态集&lt;/strong&gt;，&lt;strong&gt;边（从一个状态到另一个状态）&lt;/strong&gt;，&lt;strong&gt;边上的符号&lt;/strong&gt;，&lt;strong&gt;开始状态&lt;/strong&gt; 和 &lt;strong&gt;终结状态&lt;/strong&gt; 组成。&lt;/p&gt;

&lt;p&gt;有限自动机分为两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA 确定性有限自动机：从一个状态接收，只有唯一确定的边指向另一个状态。&lt;/li&gt;
  &lt;li&gt;NFA 非确定性有限自动机：从一个状态接收，有多个不同的状态可以到达。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此，我们可以给上面的词法规则画出如下的几个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_1.png&quot; alt=&quot;Fig 2.3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们也可以写成一个状态机转化图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/state_machine_diagram_2.png&quot; alt=&quot;Fig 2.4&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;exercises&quot;&gt;EXERCISES&lt;/h2&gt;

&lt;p&gt;2.1 Write regular expressions for each of the following.&lt;/p&gt;

&lt;p&gt;a. String over the alphabet $ \{ a,b,c \} $ where the first $a$ precedes the first $b$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：因为必须第一个 $a$ 出现在第一个 $b$ 后面，所以实际上只有两种情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;第一个 $a$ 前面只有 $c$&lt;/li&gt;
    &lt;li&gt;没有出现 $a$&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ c^\ast a[abc]^\ast \mid [bc]^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;b. String over the alphabet {a,b,c} with an even number of a’s.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路：需要 $a$ 的个数是偶数个
同样也分解情况。&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;两个 $a$ 连续出现&lt;/li&gt;
    &lt;li&gt;两个 $a$ 没有连续出现，中间有其他字符&lt;/li&gt;
    &lt;li&gt;可以为空
将上面的三种情况组合起来，得到答案&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;$ (a([bc]^\ast aa[bc]^\ast )^\ast a)^\ast $&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;c. Binary numbers that are multiples of four.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$0\mid1^\ast00$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;d. Binary numbers that are greater than 101001.&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;e. String over the alphabet {a,b,c} that don’t contain the contiguous string baa.&lt;/p&gt;

&lt;p&gt;f. The language of nonnegative integer constants in C, where numbers beginning with 0 are octal constants and other numbers are decimal constants.&lt;/p&gt;

&lt;p&gt;g. Binary numbers n such that there exists an integer solution of $a^n + b^n = c^n$.&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">『Modern Compiler Implementation in C』词法分析部分笔记和总结。</summary></entry><entry><title type="html">Notes on Machine Learning on Coursera</title><link href="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html" rel="alternate" type="text/html" title="Notes on Machine Learning on Coursera" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera</id><content type="html" xml:base="http://localhost:4000/2018/04/25/notes-of-machine-larning-on-coursera.html">&lt;p&gt;I always want to learn Machine Learning and finally I got time.&lt;/p&gt;

&lt;p&gt;I first started with the open class CS 229 Machine Learning from Stanford by Andrew Ng. But I failed after 2 classes, because Andrew Ng skipped some math detail that I forget the knowledge of calculus and linear algebra.&lt;/p&gt;

&lt;p&gt;Then I find the Machine Learning by Andrew Ng on &lt;a href=&quot;http://www.coursera.com/&quot;&gt;Coursera&lt;/a&gt; is great.&lt;/p&gt;

&lt;p&gt;The learning curve of class is more gentle, and all math details are covered in the course.&lt;/p&gt;

&lt;p&gt;So if you want to learning machine learning, I highly recommend you try this course. All you want to know is the basic knowledge of calculus and linear algebra, which also covered in the course.&lt;/p&gt;

&lt;p&gt;Yeah!&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">I always want to learn Machine Learning and finally I got time.</summary></entry><entry><title type="html">《头号玩家》</title><link href="http://localhost:4000/2018/04/02/ready-player-one.html" rel="alternate" type="text/html" title="《头号玩家》" /><published>2018-04-02T00:00:00+08:00</published><updated>2018-04-02T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/02/ready-player-one</id><content type="html" xml:base="http://localhost:4000/2018/04/02/ready-player-one.html">&lt;p&gt;看完《头号玩家》后，有一个问题一直在脑海里盘旋：
『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』&lt;/p&gt;

&lt;p&gt;到刚才，在微博上看到梅原大吾用隆完全格挡春丽的大招时，我才忽然明白。&lt;/p&gt;

&lt;p&gt;《头号玩家》带给我的感觉：&lt;/p&gt;

&lt;p&gt;它瞬间把我拉回了童年，那个在一群人在家里，围着游戏机一起通关的场景。&lt;/p&gt;

&lt;p&gt;之所以喜悦是因为那种久违的感觉，而忧伤是，你知道永远也不会再回去了。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">看完《头号玩家》后，有一个问题一直在脑海里盘旋： 『到底是什么触动了我，让我在看完电影后感到那么喜悦却又有点忧伤？』</summary></entry><entry><title type="html">My New Rules of Life</title><link href="http://localhost:4000/2018/03/02/my-new-rules-of-life.html" rel="alternate" type="text/html" title="My New Rules of Life" /><published>2018-03-02T13:56:00+08:00</published><updated>2018-03-02T13:56:00+08:00</updated><id>http://localhost:4000/2018/03/02/my-new-rules-of-life</id><content type="html" xml:base="http://localhost:4000/2018/03/02/my-new-rules-of-life.html">&lt;h4 id=&quot;things-i-wont-do-in-the-future&quot;&gt;Things I won’t do in the future&lt;/h4&gt;

&lt;p&gt;1 Alchohol.&lt;/p&gt;

&lt;p&gt;2 Eating meat except chicken and fish.&lt;/p&gt;

&lt;p&gt;3 Cigarette.&lt;/p&gt;

&lt;p&gt;4 Fast food, sugure, carbonated soft drinks.&lt;/p&gt;

&lt;h4 id=&quot;things-i-want&quot;&gt;Things I want&lt;/h4&gt;

&lt;p&gt;1 Exercises.&lt;/p&gt;

&lt;p&gt;2 Sleep early and get up early.&lt;/p&gt;

&lt;p&gt;3 Reading.&lt;/p&gt;</content><author><name></name></author><summary type="html">Things I won’t do in the future</summary></entry><entry><title type="html">两部电影和下一步</title><link href="http://localhost:4000/2018/01/10/recent.html" rel="alternate" type="text/html" title="两部电影和下一步" /><published>2018-01-10T00:15:00+08:00</published><updated>2018-01-10T00:15:00+08:00</updated><id>http://localhost:4000/2018/01/10/recent</id><content type="html" xml:base="http://localhost:4000/2018/01/10/recent.html">&lt;p&gt;最近看了两部有意思的电影。《一日情人》和《三块广告牌》。&lt;/p&gt;

&lt;p&gt;《一日情人》是一部法国电影。工作后，就一直没有心思停下来看这样“絮絮叨叨”的电影了，好像，电影里所探讨的问题，琐碎得遥远。&lt;/p&gt;

&lt;p&gt;7 分吧，推荐喜欢这类电影的人看一看。&lt;/p&gt;

&lt;p&gt;这里放上几张好看的剧照：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2457077051.jpg&quot; alt=&quot;剧照1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2457077066.jpg&quot; alt=&quot;剧照2&quot; /&gt;
&lt;img src=&quot;/assets/images/p2494758206.jpg&quot; alt=&quot;剧照3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而另一部电影《三块广告牌》，则是刚刚过去的75届金球奖最佳剧情片得主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2510412903.jpg&quot; alt=&quot;海报1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2510431925.jpg&quot; alt=&quot;剧照1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部电影的剧情结构让我想起了几年前看的《Crash》。多个人物之间的冲突，以及人物，情节与大环境之间的相互影响，都像极了《Crash》。&lt;/p&gt;

&lt;p&gt;9 分推荐。&lt;/p&gt;

&lt;p&gt;同一位导演我还看过另一部作品《在布鲁日》（又名《杀手没有假期》），当时没有看得太明白，只是觉得非常有意思。&lt;/p&gt;

&lt;p&gt;关于我的下一步。在考虑了几天之后，我决定正式接受老陆的工作，完成 DearID 的项目。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">最近看了两部有意思的电影。《一日情人》和《三块广告牌》。</summary></entry><entry><title type="html">时间</title><link href="http://localhost:4000/2018/01/03/time.html" rel="alternate" type="text/html" title="时间" /><published>2018-01-03T23:05:00+08:00</published><updated>2018-01-03T23:05:00+08:00</updated><id>http://localhost:4000/2018/01/03/time</id><content type="html" xml:base="http://localhost:4000/2018/01/03/time.html">&lt;p&gt;对于一个人而言，过去的生活到底意味着什么？时间又是什么？&lt;/p&gt;

&lt;p&gt;2016 年我失去了一位很重要的亲人，但是现在去回忆，当时所有的痛苦都变得平淡了。那么，那些原本经历的事情最后变成了什么？&lt;/p&gt;

&lt;p&gt;时间不是连续的，因为人的大脑和经验不是连续的。时间一旦消失，人对于时间的感知就消失了。反过来也可以认为，对于未来时间的感知实际上也是虚假的。如果我们迫切的希望眼前的时间快速的过去，那意味着对于即将到来的事情而言，此时此刻是不重要的。&lt;/p&gt;

&lt;p&gt;但是，如果此时此刻是不重要的，那为什么即将到来的事情是重要的？我的意思是，为什么可以不在乎此时此刻而更加在乎即将到来的事情？&lt;/p&gt;

&lt;p&gt;但是，假设一种极端情况，如果24小时后我要被枪决，或者我知道自己的生命只剩几个月了。也就是说，将要到来的一件事，不只是非常重要，而是直接结束了一切。那么，此时此刻还重要吗？我以什么样的方式过，做什么事情还重要吗？如果不重要，为什么50年就是重要的？因为时间的长度吗？&lt;/p&gt;

&lt;p&gt;我已经坚信一个结论：时间的长度本身是不重要的。50年和50天之间的区别只在于这段时间内做的事情。如果 50 天我去了马丘比丘，去了埃及，去了复活节岛。而 50 年里，我追求安全感的生活让我什么都没做，想去的地方，想做的事情一件也没有达成。那显然我会选择 50 天。&lt;/p&gt;

&lt;p&gt;但我并不是要去藐视时间，觉得时间（生命）是不重要的，我太希望那位离开的亲人活得更久一点了。&lt;/p&gt;

&lt;p&gt;时间好像是一种介质，它将我们（做的事情，经历）与（我们的）生活联系起来，从而赋予（我们的）生命以意义。所以，“怎么利用时间？”这个问题的重点其实是，在时间中我们做什么？因为时间是没有办法控制的，无论我们做什么，做多做少，时间最后都会消失，能控制的只是“做什么”。&lt;/p&gt;

&lt;p&gt;所以，“现在做什么”比什么都重要。&lt;/p&gt;

&lt;p&gt;下一个问题：怎么决定“现在做什么”？&lt;/p&gt;

&lt;p&gt;前两天看到了贝索斯在亚马逊早起的一个采访。当时亚马逊应该已经是一个有所成就的图书销售网站了，所以，贝索斯可以认为是一个成功的人了，至少再外界看来。所以，在采访中，主持人问贝索斯说，“我以为你会是一个享受当下的人”。贝索斯非常干脆的回答了这个问题，说他不是这样的人，他做事遵循的原则是，“最小后悔原则”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;，这个词我是第一次听说，当然，一听到就觉得非常有道理。&lt;/p&gt;

&lt;p&gt;但是随之而来产生了几个疑问是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;的目标是什么？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从采访中，可以看出，至少贝索斯认为现在虽然已经是还算成功的状态了，但是在他能看到的地方，还有更重要的事情去做。所以，为了达到这个目的，此时此刻，享受当下是非常愚蠢的。&lt;/p&gt;

&lt;p&gt;所以，要能看到“未来”。要大概的知道“未来”的样子，然后为之制定一套行为标准，其实并不需要清晰的知道“未来”，因为谁也不可能清楚的预测。但是，通过想象未来的样子，可以看到方向。比如，我并不知道未来具体是什么情景，但是大概知道我想要去日本，所以现在开始学好日语就是一条&lt;strong&gt;最小后悔原则&lt;/strong&gt;。其实，另一个问题也有了：&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？那就是在此时此刻尽力了。&lt;/p&gt;

&lt;p&gt;但是这个“尽力”并不是精疲力劲的意思，精疲力劲实际上意味着透支未来，以一种低效的方式去话费未来的时间。尽力，可以认为是相对努力，已目前能达到的最大状态工作，但又不至于过于疲惫。&lt;/p&gt;

&lt;p&gt;所以，决定“此时此刻”的是未来，但创造未来的，确实“此时此刻”。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">对于一个人而言，过去的生活到底意味着什么？时间又是什么？</summary></entry><entry><title type="html">Deathland Studio 开张</title><link href="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html" rel="alternate" type="text/html" title="Deathland Studio 开张" /><published>2018-01-01T15:26:33+08:00</published><updated>2018-01-01T15:26:33+08:00</updated><id>http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio</id><content type="html" xml:base="http://localhost:4000/deathlandstudio/2018/01/01/deathland-studio.html">&lt;p&gt;今天 2018 年的第一天，Deathland Studio 工作室正式成立。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/deathland_studio_logo.jpeg&quot; alt=&quot;Logo&quot; /&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">今天 2018 年的第一天，Deathland Studio 工作室正式成立。</summary></entry><entry><title type="html">Mac Root Bug</title><link href="http://localhost:4000/mac/2017/12/07/mac-root-bug.html" rel="alternate" type="text/html" title="Mac Root Bug" /><published>2017-12-07T10:11:00+08:00</published><updated>2017-12-07T10:11:00+08:00</updated><id>http://localhost:4000/mac/2017/12/07/mac-root-bug</id><content type="html" xml:base="http://localhost:4000/mac/2017/12/07/mac-root-bug.html">&lt;p&gt;前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;现象&quot;&gt;现象&lt;/h3&gt;

&lt;p&gt;这个漏洞的现象是：在任何地方需要管理员授权时，输入 root 用户名，密码为空，连续输入三次后，就获得了 root 权限。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;修改 root 密码的方法，参看这篇 Apple 的&lt;a href=&quot;https://support.apple.com/kb/PH6515?locale=zh_CN&amp;amp;viewlocale=zh_CN&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。</summary></entry><entry><title type="html">塞尔达传说-荒野之息 第一部分</title><link href="http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1.html" rel="alternate" type="text/html" title="塞尔达传说-荒野之息 第一部分" /><published>2017-12-05T10:11:00+08:00</published><updated>2017-12-05T10:11:00+08:00</updated><id>http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1</id><content type="html" xml:base="http://localhost:4000/zelda/2017/12/05/the-legend-of-zelda-part-1.html">&lt;p&gt;在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。&lt;/p&gt;

&lt;p&gt;不过，在玩了几十个小时候，我还是决定收回这句疯狂的赞美，把它列为：最近几年来最让我投入的游戏。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;我一直偏爱 RPG 以及 开放世界。最早震撼我的游戏是《侠盗猎车手 — 罪恶都市》，
当年可以驾驶各种车辆穿梭在虚拟城市里的自由深深吸引了我，我想驾驶车辆驶过每一条马路，
想进入每一个可以进入的角落，想和每一个虚拟人物交谈，想进入每一座房子。&lt;/p&gt;

&lt;p&gt;但是，一个开放世界，最大的问题是无论我们花费多少时间去补充游戏的内容，只要玩家遇到一个地方无法通过，或者逻辑上的错误，那种开放世界的真实感就会土崩瓦解。
所以，目前的技术来说，做出一个完全真实的开放世界，几乎是不可能。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。</summary></entry><entry><title type="html">一个问题？</title><link href="http://localhost:4000/dionsradio/2017/12/04/dionsradio.html" rel="alternate" type="text/html" title="一个问题？" /><published>2017-12-04T20:11:00+08:00</published><updated>2017-12-04T20:11:00+08:00</updated><id>http://localhost:4000/dionsradio/2017/12/04/dionsradio</id><content type="html" xml:base="http://localhost:4000/dionsradio/2017/12/04/dionsradio.html">&lt;p&gt;1000年后，在科技高度发达的年代里，人类还会相互对抗，发生战争吗？会把目光投向宇宙吗？&lt;/p&gt;</content><author><name>DionsRadio</name></author><summary type="html">1000年后，在科技高度发达的年代里，人类还会相互对抗，发生战争吗？会把目光投向宇宙吗？</summary></entry></feed>