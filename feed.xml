<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://www.teslalee.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.teslalee.com/" rel="alternate" type="text/html" /><updated>2018-01-13T00:38:26+08:00</updated><id>http://www.teslalee.com/</id><title type="html">Code Cube</title><subtitle></subtitle><entry><title type="html">两部电影和下一步</title><link href="http://www.teslalee.com/2018/01/10/recent.html" rel="alternate" type="text/html" title="两部电影和下一步" /><published>2018-01-10T00:15:00+08:00</published><updated>2018-01-10T00:15:00+08:00</updated><id>http://www.teslalee.com/2018/01/10/recent</id><content type="html" xml:base="http://www.teslalee.com/2018/01/10/recent.html">&lt;p&gt;最近看了两部有意思的电影。《一日情人》和《三块广告牌》。&lt;/p&gt;

&lt;p&gt;《一日情人》是一部法国电影。工作后，就一直没有心思停下来看这样“絮絮叨叨”的电影了，好像，电影里所探讨的问题，琐碎得遥远。&lt;/p&gt;

&lt;p&gt;7 分吧，推荐喜欢这类电影的人看一看。&lt;/p&gt;

&lt;p&gt;这里放上几张好看的剧照：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2457077051.jpg&quot; alt=&quot;剧照1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2457077066.jpg&quot; alt=&quot;剧照2&quot; /&gt;
&lt;img src=&quot;/assets/images/p2494758206.jpg&quot; alt=&quot;剧照3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而另一部电影《三块广告牌》，则是刚刚过去的75届金球奖最佳剧情片得主。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/p2510412903.jpg&quot; alt=&quot;海报1&quot; /&gt;
&lt;img src=&quot;/assets/images/p2510431925.jpg&quot; alt=&quot;剧照1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部电影的剧情结构让我想起了几年前看的《Crash》。多个人物之间的冲突，以及人物，情节与大环境之间的相互影响，都像极了《Crash》。&lt;/p&gt;

&lt;p&gt;9 分推荐。&lt;/p&gt;

&lt;p&gt;同一位导演我还看过另一部作品《在布鲁日》（又名《杀手没有假期》），当时没有看得太明白，只是觉得非常有意思。&lt;/p&gt;

&lt;p&gt;关于我的下一步。在考虑了几天之后，我决定正式接受老陆的工作，完成 DearID 的项目。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">最近看了两部有意思的电影。《一日情人》和《三块广告牌》。</summary></entry><entry><title type="html">时间</title><link href="http://www.teslalee.com/2018/01/03/time.html" rel="alternate" type="text/html" title="时间" /><published>2018-01-03T23:05:00+08:00</published><updated>2018-01-03T23:05:00+08:00</updated><id>http://www.teslalee.com/2018/01/03/time</id><content type="html" xml:base="http://www.teslalee.com/2018/01/03/time.html">&lt;p&gt;对于一个人而言，过去的生活到底意味着什么？时间又是什么？&lt;/p&gt;

&lt;p&gt;2016 年我失去了一位很重要的亲人，但是现在去回忆，当时所有的痛苦都变得平淡了。那么，那些原本经历的事情最后变成了什么？&lt;/p&gt;

&lt;p&gt;时间不是连续的，因为人的大脑和经验不是连续的。时间一旦消失，人对于时间的感知就消失了。反过来也可以认为，对于未来时间的感知实际上也是虚假的。如果我们迫切的希望眼前的时间快速的过去，那意味着对于即将到来的事情而言，此时此刻是不重要的。&lt;/p&gt;

&lt;p&gt;但是，如果此时此刻是不重要的，那为什么即将到来的事情是重要的？我的意思是，为什么可以不在乎此时此刻而更加在乎即将到来的事情？&lt;/p&gt;

&lt;p&gt;但是，假设一种极端情况，如果24小时后我要被枪决，或者我知道自己的生命只剩几个月了。也就是说，将要到来的一件事，不只是非常重要，而是直接结束了一切。那么，此时此刻还重要吗？我以什么样的方式过，做什么事情还重要吗？如果不重要，为什么50年就是重要的？因为时间的长度吗？&lt;/p&gt;

&lt;p&gt;我已经坚信一个结论：时间的长度本身是不重要的。50年和50天之间的区别只在于这段时间内做的事情。如果 50 天我去了马丘比丘，去了埃及，去了复活节岛。而 50 年里，我追求安全感的生活让我什么都没做，想去的地方，想做的事情一件也没有达成。那显然我会选择 50 天。&lt;/p&gt;

&lt;p&gt;但我并不是要去藐视时间，觉得时间（生命）是不重要的，我太希望那位离开的亲人活得更久一点了。&lt;/p&gt;

&lt;p&gt;时间好像是一种介质，它将我们（做的事情，经历）与（我们的）生活联系起来，从而赋予（我们的）生命以意义。所以，“怎么利用时间？”这个问题的重点其实是，在时间中我们做什么？因为时间是没有办法控制的，无论我们做什么，做多做少，时间最后都会消失，能控制的只是“做什么”。&lt;/p&gt;

&lt;p&gt;所以，“现在做什么”比什么都重要。&lt;/p&gt;

&lt;p&gt;下一个问题：怎么决定“现在做什么”？&lt;/p&gt;

&lt;p&gt;前两天看到了贝索斯在亚马逊早起的一个采访。当时亚马逊应该已经是一个有所成就的图书销售网站了，所以，贝索斯可以认为是一个成功的人了，至少再外界看来。所以，在采访中，主持人问贝索斯说，“我以为你会是一个享受当下的人”。贝索斯非常干脆的回答了这个问题，说他不是这样的人，他做事遵循的原则是，“最小后悔原则”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;，这个词我是第一次听说，当然，一听到就觉得非常有道理。&lt;/p&gt;

&lt;p&gt;但是随之而来产生了几个疑问是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;最小后悔原则&lt;/strong&gt;的目标是什么？&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从采访中，可以看出，至少贝索斯认为现在虽然已经是还算成功的状态了，但是在他能看到的地方，还有更重要的事情去做。所以，为了达到这个目的，此时此刻，享受当下是非常愚蠢的。&lt;/p&gt;

&lt;p&gt;所以，要能看到“未来”。要大概的知道“未来”的样子，然后为之制定一套行为标准，其实并不需要清晰的知道“未来”，因为谁也不可能清楚的预测。但是，通过想象未来的样子，可以看到方向。比如，我并不知道未来具体是什么情景，但是大概知道我想要去日本，所以现在开始学好日语就是一条&lt;strong&gt;最小后悔原则&lt;/strong&gt;。其实，另一个问题也有了：&lt;strong&gt;最小&lt;/strong&gt;的标准是什么？那就是在此时此刻尽力了。&lt;/p&gt;

&lt;p&gt;但是这个“尽力”并不是精疲力劲的意思，精疲力劲实际上意味着透支未来，以一种低效的方式去话费未来的时间。尽力，可以认为是相对努力，已目前能达到的最大状态工作，但又不至于过于疲惫。&lt;/p&gt;

&lt;p&gt;所以，决定“此时此刻”的是未来，但创造未来的，确实“此时此刻”。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">对于一个人而言，过去的生活到底意味着什么？时间又是什么？</summary></entry><entry><title type="html">Deathland Studio 开张</title><link href="http://www.teslalee.com/deathlandstudio/2018/01/01/deathland-studio.html" rel="alternate" type="text/html" title="Deathland Studio 开张" /><published>2018-01-01T15:26:33+08:00</published><updated>2018-01-01T15:26:33+08:00</updated><id>http://www.teslalee.com/deathlandstudio/2018/01/01/deathland-studio</id><content type="html" xml:base="http://www.teslalee.com/deathlandstudio/2018/01/01/deathland-studio.html">&lt;p&gt;今天 2018 年的第一天，Deathland Studio 工作室正式成立。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/deathland_studio_logo.jpeg&quot; alt=&quot;Logo&quot; /&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">今天 2018 年的第一天，Deathland Studio 工作室正式成立。</summary></entry><entry><title type="html">Mac Root Bug</title><link href="http://www.teslalee.com/mac/2017/12/07/mac-root-bug.html" rel="alternate" type="text/html" title="Mac Root Bug" /><published>2017-12-07T10:11:00+08:00</published><updated>2017-12-07T10:11:00+08:00</updated><id>http://www.teslalee.com/mac/2017/12/07/mac-root-bug</id><content type="html" xml:base="http://www.teslalee.com/mac/2017/12/07/mac-root-bug.html">&lt;p&gt;前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h3 id=&quot;现象&quot;&gt;现象&lt;/h3&gt;

&lt;p&gt;这个漏洞的现象是：在任何地方需要管理员授权时，输入 root 用户名，密码为空，连续输入三次后，就获得了 root 权限。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;p&gt;修改 root 密码的方法，参看这篇 Apple 的&lt;a href=&quot;https://support.apple.com/kb/PH6515?locale=zh_CN&amp;amp;viewlocale=zh_CN&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">前阵子 Mac 爆出了让人尴尬的安全漏洞：默认情况下，root 用户的密码为空。</summary></entry><entry><title type="html">塞尔达传说-荒野之息 第一部分</title><link href="http://www.teslalee.com/zelda/2017/12/05/the-legend-of-zelda-part-1.html" rel="alternate" type="text/html" title="塞尔达传说-荒野之息 第一部分" /><published>2017-12-05T10:11:00+08:00</published><updated>2017-12-05T10:11:00+08:00</updated><id>http://www.teslalee.com/zelda/2017/12/05/the-legend-of-zelda-part-1</id><content type="html" xml:base="http://www.teslalee.com/zelda/2017/12/05/the-legend-of-zelda-part-1.html">&lt;p&gt;在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。&lt;/p&gt;

&lt;p&gt;不过，在玩了几十个小时候，我还是决定收回这句疯狂的赞美，把它列为：最近几年来最让我投入的游戏。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;我一直偏爱 RPG 以及 开放世界。最早震撼我的游戏是《侠盗猎车手 — 罪恶都市》，
当年可以驾驶各种车辆穿梭在虚拟城市里的自由深深吸引了我，我想驾驶车辆驶过每一条马路，
想进入每一个可以进入的角落，想和每一个虚拟人物交谈，想进入每一座房子。&lt;/p&gt;

&lt;p&gt;但是，一个开放世界，最大的问题是无论我们花费多少时间去补充游戏的内容，只要玩家遇到一个地方无法通过，或者逻辑上的错误，那种开放世界的真实感就会土崩瓦解。
所以，目前的技术来说，做出一个完全真实的开放世界，几乎是不可能。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">在玩了《荒野之息》后，才发现自己想要的开放世界是什么样子。这可能是我最近几年，甚至十年来玩的最好的游戏了。</summary></entry><entry><title type="html">一个问题？</title><link href="http://www.teslalee.com/dionsradio/2017/12/04/dionsradio.html" rel="alternate" type="text/html" title="一个问题？" /><published>2017-12-04T20:11:00+08:00</published><updated>2017-12-04T20:11:00+08:00</updated><id>http://www.teslalee.com/dionsradio/2017/12/04/dionsradio</id><content type="html" xml:base="http://www.teslalee.com/dionsradio/2017/12/04/dionsradio.html">&lt;p&gt;1000年后，在科技高度发达的年代里，人类还会相互对抗，发生战争吗？会把目光投向宇宙吗？&lt;/p&gt;</content><author><name>DionsRadio</name></author><summary type="html">1000年后，在科技高度发达的年代里，人类还会相互对抗，发生战争吗？会把目光投向宇宙吗？</summary></entry><entry><title type="html">Ruby Refinements Documented</title><link href="http://www.teslalee.com/ruby/2017/11/22/refinements.html" rel="alternate" type="text/html" title="Ruby Refinements Documented" /><published>2017-11-22T22:53:12+08:00</published><updated>2017-11-22T22:53:12+08:00</updated><id>http://www.teslalee.com/ruby/2017/11/22/refinements</id><content type="html" xml:base="http://www.teslalee.com/ruby/2017/11/22/refinements.html">&lt;p&gt;本文主要记录了 Refinement 使用的一些要点，内容基本来自 Ruby 的官方文档以及 Metaprogramming Ruby 这本书。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;有时，我们往往会遇到一些情况，需要对系统的类做重新打开的操作，同时再添加一些自己的扩展。Ruby 提供了多种不同的方法来实现，其中之一就是打开类。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;a_new_method&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但这样的写法有一个问题，这样的修改是全局的，一旦定义，整个系统都会受影响。如果出错，将会是灾难性的。
那么，有没有什么方法，能够将这个修改只在我需要使用的范围内起作用呢？ Ruby 提供了 Refinement 来帮助你实现。&lt;/p&gt;

&lt;p&gt;先看一段 Ruby 官方文档。来自 Ruby 2.2.4&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Refinements are designed to reduce the impact of monkey patching on other users of the monkey-patched class.Refinements provide a way to extend a class locally.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面下看一个典型的 Refinement 的例子：&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C#foo&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C# foo in M&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Module#refine&lt;/code&gt; 只能接收 class 作为参数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Module#refine&lt;/code&gt; 会创建一个匿名 module 并且修改包裹在内。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;refine&lt;/code&gt; block 中，&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; 指向这个匿名 module&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;作用域&quot;&gt;作用域&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;You may only activate refinements at top-level, not inside any class, module or method scope. You may activate refinements in a string passed to Kernel#eval that is evaluated at top-level. Refinements are active until the end of the file or the end of the eval string, respectively.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面用官方的两个例子来说明 Refinement 的作用域问题&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C#foo in M&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;# prints &quot;C#foo in M&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;call_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; raises NoMethodError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这里，当调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_foo&lt;/code&gt; 时，控制权从当前作用域（假设叫做 Scope A）进入到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_foo&lt;/code&gt; 这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;method&lt;/code&gt; 的作用域（Scope B）中去了。
所以，根据规则&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;当控制权发生改变，跳出了当前 Refinement 生效的作用域时，Refinement 失效。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来第二个例子：&lt;/p&gt;

&lt;p&gt;c.rb:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;m.rb&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;C#foo in M&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;m_user.rb&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;m&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MUser&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;main.rb&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;m_user&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;MUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# prints &quot;C#foo in M&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;#=&amp;gt; raises NoMethodError&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以认为，Refinement 生效的作用域只在 m_user.rb 这个文件内。当我们调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;m_user.call_foo(x)&lt;/code&gt; 时，我们进入了 m_user.rb 这个文件的作用域，也就是 Refinement 生效了。而结束后调用后，又回到了 main.rb 这个文件的作用域内，此时 Refinement 已经失效，所以爆了 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoMethodError&lt;/code&gt; 这个 Exception。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;在定义 Refinement 时，在同一个 module 中的所有 refinements 都是相互生效的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面这一条有点奇怪。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;You may also activate refinements in a class or module definition, in which case the refinements are activated from the point where using is called to the end of the class or module definition:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我觉得这段话和上面的那段话&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;You may only activate refinements at top-level, not inside any class, module or method scope. You may activate refinements in a string passed to Kernel#eval that is evaluated at top-level. Refinements are active until the end of the file or the end of the eval string, respectively.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;有点矛盾，我现在的疑问是，是不是我对于 TOP LEVEL 这个概念理解有偏差。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是对于这个定义，我没有异议。看下面。&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# not activated here&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# not activated here&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# activated here&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# activated here&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# activated here&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# not activated here&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;有一点要注意：M 只在这次的 Scope 中生效，后面再打开 Foo 中，M 也不会生效。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;方法查找&quot;&gt;方法查找&lt;/h3&gt;

&lt;p&gt;当在一个类 C 的实体上查找方法时，顺序是这样的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果有多个 Refinement 生效，那么将按照每个 refinement 生效的顺序，反向查找 refinement 内部的方法。
    &lt;ul&gt;
      &lt;li&gt;refinement 中 prepend 的 module 中的 method&lt;/li&gt;
      &lt;li&gt;refinement 中的 method&lt;/li&gt;
      &lt;li&gt;refinement 中 include 的 module 中的 method&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;prepend 的 module 中的 method&lt;/li&gt;
  &lt;li&gt;C 中的 method&lt;/li&gt;
  &lt;li&gt;include 的 module 中的 method
如果没有，则继续查找 superclass，重复上面的顺序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如下面的代码&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M1&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in M1&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M2&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in M2&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M3&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in M3&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M4&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in M4&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;M5&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in M5&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AExtend&lt;/span&gt; 
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prepend&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M2&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in AExtend&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;AExtend&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M3&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;prepend&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;M4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;AExtend&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# A foo in M2&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ancestors&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [M4, A, M3, Objcet, Kernel, BasicObject]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于第一个输出，其实没有异议。那么为什么此时打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;A.ancestors&lt;/code&gt; 时，却没有 &lt;code class=&quot;highlighter-rouge&quot;&gt;M1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;M2&lt;/code&gt; 呢？
我倾向于认为，因为进入到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ancestors&lt;/code&gt; 这个函数里，所以控制权已经发生了改变， AExtend 已经失效了。&lt;/p&gt;

&lt;h3 id=&quot;super&quot;&gt;super&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;super&lt;/code&gt; 的方法查找&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查找所有 included modules&lt;/li&gt;
  &lt;li&gt;如果当前是 refinement class，重复上面步骤&lt;/li&gt;
  &lt;li&gt;如果当前 class 有 superclass，则在 superclass 上重复上面步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;非直接调用&quot;&gt;非直接调用&lt;/h3&gt;
&lt;p&gt;目前 refinement 对于 Kernel#send，Kernel#method 以及 Kernel#respond_to? 都不起作用&lt;/p&gt;

&lt;h3 id=&quot;在-include-中的方法查找此处已经被移除&quot;&gt;在 include 中的方法查找【此处已经被移除】&lt;/h3&gt;
&lt;p&gt;看下面的示例&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AExtend1&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in AExtend1&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AExtend2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;refine&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
      &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A foo in AExtend2&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;AExtend3&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;AExtend2&lt;/span&gt;
  &lt;span class=&quot;kp&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;AExtend1&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# refine A do&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#   def foo&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#     puts &quot;A foo in AExtend3&quot;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#   end&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;AExtend3&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# A foo in AExtend1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;方法查找的顺序是&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;先查找 AExtend3 中的 refinement&lt;/li&gt;
  &lt;li&gt;再按照 prepend 以及 include 的顺序来查找，也就是 ancestors 继承链中的顺序从前往后查找。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;第一次了解 Refinement，感觉还有一点乱，虽然可以用来避免 Monkey Patch 的全局影响问题，但是要想使用好，还需要花时间。&lt;/p&gt;</content><author><name>Tesla Lee</name></author><summary type="html">本文主要记录了 Refinement 使用的一些要点，内容基本来自 Ruby 的官方文档以及 Metaprogramming Ruby 这本书。</summary></entry></feed>